<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>EDGI FOIA Network</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; background: #0a0a0f; font-family: system-ui, -apple-system, sans-serif; overflow: hidden; }
        #sigma-container { width: 100vw; height: 100vh; overflow: hidden; }
        /* Hide any scrollbars or artifacts */
        html, body { overflow: hidden; }
        canvas { display: block; }
        /* Hide Sigma's hover label layer */
        .sigma-hovers { display: none !important; }
        .sigma-container canvas:nth-child(3) { display: none !important; }

        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(15,15,20,0.95); padding: 14px;
            border-radius: 14px; color: #fff; width: 280px; z-index: 10;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }
        h1 { margin: 0 0 8px; font-size: 17px; color: #a78bfa; font-weight: 600; }
        .explain { font-size: 11px; color: #9ca3af; margin-bottom: 10px; line-height: 1.4; }
        .explain b { color: #e5e7eb; }
        .stat { font-size: 11px; color: #9ca3af; margin: 3px 0; }
        .stat b { color: #fff; }

        input[type=text] {
            width: 100%; padding: 10px 12px; margin: 8px 0;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px; color: #fff; font-size: 13px; transition: all 0.2s;
        }
        input[type=text]:focus { outline: none; border-color: #a78bfa; background: rgba(167,139,250,0.1); }
        input[type=text]::placeholder { color: #6b7280; }

        #results { max-height: 120px; overflow-y: auto; }
        .result { padding: 8px 10px; cursor: pointer; font-size: 12px; color: #d1d5db; border-radius: 6px; margin: 2px 0; transition: all 0.15s; }
        .result:hover { background: rgba(167,139,250,0.2); color: #fff; }

        label { display: block; margin-top: 10px; font-size: 10px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; }
        input[type=range] { width: 100%; margin: 6px 0; -webkit-appearance: none; background: rgba(255,255,255,0.1); height: 5px; border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: #a78bfa; border-radius: 50%; cursor: pointer; }

        #info {
            position: fixed; top: 20px; right: 20px;
            background: rgba(15,15,20,0.95); padding: 20px;
            border-radius: 16px; color: #fff; display: none; z-index: 10;
            width: 340px; border: 1px solid rgba(255,255,255,0.1);
            max-height: calc(100vh - 40px); overflow-y: auto;
        }
        #info h3 { margin: 0 0 12px; color: #a78bfa; font-size: 18px; font-weight: 600; padding-right: 30px; }
        #info.locked { border-color: #a78bfa; box-shadow: 0 0 30px rgba(167,139,250,0.2); }
        #info.minimized { height: auto; max-height: none; }
        #info.minimized .info-content { display: none; }
        #minimize-btn {
            position: absolute; top: 16px; right: 16px;
            background: rgba(255,255,255,0.1); border: none; border-radius: 6px;
            color: #9ca3af; width: 28px; height: 28px; cursor: pointer;
            font-size: 16px; line-height: 1; transition: all 0.2s;
        }
        #minimize-btn:hover { background: rgba(255,255,255,0.2); color: #fff; }

        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #a78bfa; font-size: 18px; text-align: center; }
        .dancing-ninja { font-size: 80px; animation: dance 1s ease-in-out infinite; }
        @keyframes dance {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            25% { transform: translateY(-20px) rotate(5deg); }
            50% { transform: translateY(0) rotate(-5deg); }
            75% { transform: translateY(-10px) rotate(5deg); }
        }

        .legend { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        .legend-title { font-size: 10px; color: #6b7280; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
        .legend-item { display: flex; align-items: center; margin: 3px 0; font-size: 10px; color: #9ca3af; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; }

        .btn { display: block; margin-top: 8px; padding: 10px 14px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; width: 100%; font-size: 12px; transition: all 0.2s; text-align: center; }
        #clear-btn { display: none; background: #a78bfa; color: #000; }
        #clear-btn:hover { background: #c4b5fd; }
        #toxicdocs-btn { background: linear-gradient(135deg, #f59e0b, #d97706); color: #000; }
        #toxicdocs-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(245,158,11,0.3); }
        #list-connections-btn { background: rgba(16,185,129,0.2); color: #10b981; border: 1px solid #10b981; }
        #list-connections-btn:hover { background: rgba(16,185,129,0.3); }

        #connections-list { margin-top: 10px; max-height: 200px; overflow-y: auto; }
        .conn-item { padding: 8px 0; font-size: 12px; color: #d1d5db; border-bottom: 1px solid rgba(255,255,255,0.05); transition: color 0.15s; display: flex; align-items: center; }
        .conn-item span { color: #6b7280; }
        .conn-icons { display: flex; gap: 6px; margin-right: 8px; }
        .conn-icon { cursor: pointer; font-size: 14px; padding: 2px 4px; border-radius: 4px; transition: all 0.15s; }
        .conn-icon:hover { background: rgba(255,255,255,0.1); }
        .conn-icon.reorient { color: #10b981; }
        .conn-icon.reorient:hover { color: #34d399; background: rgba(16,185,129,0.2); }
        .conn-icon.search { color: #f59e0b; }
        .conn-icon.search:hover { color: #fbbf24; background: rgba(245,158,11,0.2); }

        #zoom-controls { position: fixed; bottom: 20px; left: 20px; background: rgba(15,15,20,0.95); padding: 12px; border-radius: 12px; z-index: 10; border: 1px solid rgba(255,255,255,0.1); }
        #zoom-controls button { width: 44px; height: 44px; margin: 0 4px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; color: #fff; font-size: 22px; cursor: pointer; transition: all 0.2s; }
        #zoom-controls button:hover { background: #a78bfa; color: #000; }

        #isolate-toggle { position: fixed; bottom: 100px; left: 20px; z-index: 10; }
        #isolate-btn { padding: 14px 28px; background: rgba(255,255,255,0.05); color: #9ca3af; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s; min-width: 130px; }
        #isolate-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        #isolate-btn.active { background: #a78bfa; color: #000; border-color: #a78bfa; }

        #print-network-btn { position: fixed; bottom: 150px; left: 20px; z-index: 10; display: none; padding: 12px 20px; background: rgba(255,255,255,0.05); color: #9ca3af; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; cursor: pointer; font-weight: 500; font-size: 13px; transition: all 0.2s; }
        #print-network-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }

        /* Advanced Analytics Box - positioned bottom-right */
        #advanced-analytics {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 340px;
            max-height: calc(100vh - 100px);
            background: rgba(15,15,20,0.97);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            z-index: 10;
            cursor: grab;
            display: none;
        }
        #advanced-analytics.visible {
            display: block;
        }
        #advanced-analytics:active { cursor: grabbing; }
        #advanced-analytics.dragging { cursor: grabbing; }
        #analytics-header {
            position: sticky;
            top: 0;
            padding: 14px 20px;
            background: rgba(15,15,20,0.99);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            border-radius: 16px 16px 0 0;
            z-index: 1;
        }
        #analytics-header h3 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }
        #analytics-toggle {
            color: #9ca3af;
            font-size: 18px;
            transition: transform 0.2s;
            cursor: pointer;
        }
        #back-to-network-btn {
            padding: 6px 12px;
            background: rgba(251,191,36,0.2);
            border: 1px solid rgba(251,191,36,0.4);
            border-radius: 6px;
            color: #fbbf24;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        #back-to-network-btn:hover {
            background: rgba(251,191,36,0.3);
            border-color: rgba(251,191,36,0.6);
        }
        #collapse-btn {
            padding: 6px 12px;
            background: rgba(107,114,128,0.2);
            border: 1px solid rgba(107,114,128,0.4);
            border-radius: 6px;
            color: #9ca3af;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        #collapse-btn:hover {
            background: rgba(107,114,128,0.3);
            border-color: rgba(107,114,128,0.6);
        }
        .multiconnect-controls label {
            font-size: 11px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .clique-result-item {
            padding: 10px 12px;
            background: rgba(139,92,246,0.1);
            border: 1px solid rgba(139,92,246,0.2);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .clique-result-item:hover {
            background: rgba(139,92,246,0.2);
            border-color: rgba(139,92,246,0.4);
        }
        .clique-result-item.active {
            background: rgba(251,191,36,0.2);
            border-color: rgba(251,191,36,0.5);
        }
        .clique-members {
            font-size: 12px;
            color: #d1d5db;
            line-height: 1.5;
        }
        .clique-member {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 2px;
            font-size: 11px;
        }
        #analytics-header.collapsed #analytics-toggle { transform: rotate(-90deg); }
        #analytics-content {
            padding: 16px 20px;
            max-height: calc(100vh - 180px);
            overflow-y: scroll;
            cursor: default;
        }
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .results-header span {
            font-size: 10px;
            color: #6b7280;
        }
        .collapse-results-btn {
            padding: 2px 8px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            color: #9ca3af;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .collapse-results-btn:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }
        .analytics-section {
            margin-bottom: 20px;
        }
        .analytics-section:last-child { margin-bottom: 0; }
        .analytics-section-title {
            font-size: 11px;
            color: #8b5cf6;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        .analytics-description {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 12px;
            line-height: 1.4;
        }
        .analytics-btn {
            display: block;
            width: 100%;
            padding: 10px 14px;
            background: rgba(139,92,246,0.15);
            border: 1px solid rgba(139,92,246,0.3);
            border-radius: 8px;
            color: #a78bfa;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
        }
        .analytics-btn:hover {
            background: rgba(139,92,246,0.25);
            border-color: rgba(139,92,246,0.5);
            color: #c4b5fd;
        }
        .analytics-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .analytics-results {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        .analytics-result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 12px;
        }
        .analytics-result-item:last-child { border-bottom: none; }
        .analytics-result-name {
            color: #d1d5db;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            transition: color 0.15s;
        }
        .analytics-result-name:hover {
            color: #a78bfa;
        }
        .analytics-result-value {
            color: #a78bfa;
            font-weight: 600;
            margin-left: 10px;
        }
        .analytics-result-bar {
            width: 60px;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            margin-left: 10px;
            overflow: hidden;
        }
        .analytics-result-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #3b82f6);
            border-radius: 3px;
        }
        .analytics-insight {
            background: rgba(16,185,129,0.1);
            border: 1px solid rgba(16,185,129,0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }
        .analytics-insight-title {
            font-size: 11px;
            color: #10b981;
            font-weight: 600;
            margin-bottom: 6px;
        }
        .analytics-insight-text {
            font-size: 11px;
            color: #9ca3af;
            line-height: 1.5;
        }
        .metric-rank { color: #6b7280; font-size: 10px; margin-right: 8px; }

        .entity-toggle { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        .toggle-title { font-size: 10px; color: #6b7280; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
        .entity-toggle-btns { display: flex; gap: 6px; }
        .entity-toggle-btn { flex: 1; padding: 8px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #9ca3af; font-size: 11px; cursor: pointer; text-align: center; transition: all 0.2s; font-weight: 500; }
        .entity-toggle-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .entity-toggle-btn.active { background: #a78bfa; color: #000; border-color: #a78bfa; }
        .entity-toggle-btn.active.org { background: #8b5cf6; }

        .badge { display: inline-block; padding: 3px 8px; border-radius: 6px; font-size: 10px; margin-left: 8px; font-weight: 600; }
        .badge.person { background: rgba(96,165,250,0.2); color: #60a5fa; }
        .badge.org { background: rgba(167,139,250,0.2); color: #a78bfa; }

        #search-indicator { position: fixed; pointer-events: none; z-index: 100; display: none; text-align: center; overflow: hidden; }
        #node-ring { position: fixed; pointer-events: none; z-index: 1000; display: none; border: 3px solid #ffffff; border-radius: 50%; transform: translate(-50%, -50%); }

        /* Search between button - only shows when clicking edge node in isolated mode */
        #search-between-btn {
            display: none;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9); color: #fff;
        }
        #search-between-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(139,92,246,0.3); }
        #reorient-btn {
            display: none;
            background: linear-gradient(135deg, #10b981, #059669); color: #fff;
        }
        #reorient-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(16,185,129,0.3); }
        #download-zip-btn {
            display: none;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: #fff;
        }
        #download-zip-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(59,130,246,0.3); }
        #download-zip-btn.loading { opacity: 0.7; cursor: wait; }

        /* Toast notifications for background ZIP creation */
        #zip-toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .zip-toast {
            background: #1e293b;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 20px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        .zip-toast.closing { animation: slideOut 0.3s ease-in forwards; }
        .zip-toast-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .zip-toast-title { font-weight: 600; color: #fff; font-size: 14px; }
        .zip-toast-close { background: none; border: none; color: #64748b; cursor: pointer; font-size: 18px; padding: 0; line-height: 1; }
        .zip-toast-close:hover { color: #fff; }
        .zip-toast-body { color: #94a3b8; font-size: 13px; }
        .zip-toast-progress { height: 3px; background: rgba(255,255,255,0.1); border-radius: 2px; margin-top: 12px; overflow: hidden; }
        .zip-toast-progress-bar { height: 100%; background: linear-gradient(90deg, #3b82f6, #8b5cf6); border-radius: 2px; animation: progress 2s ease-in-out infinite; width: 30%; }
        @keyframes progress { 0% { transform: translateX(-100%); } 100% { transform: translateX(400%); } }
        .zip-toast.success { border-color: rgba(16,185,129,0.3); }
        .zip-toast.success .zip-toast-progress-bar { background: #10b981; width: 100%; animation: none; }
        .zip-toast.error { border-color: rgba(239,68,68,0.3); }
        .zip-toast-link { display: inline-block; margin-top: 10px; background: linear-gradient(135deg, #10b981, #059669); color: #fff; padding: 8px 16px; border-radius: 6px; text-decoration: none; font-size: 13px; font-weight: 500; }
        .zip-toast-link:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(16,185,129,0.3); }

        .indicator-arrow { width: 0; height: 0; border-left: 15px solid transparent; border-right: 15px solid transparent; border-top: 25px solid #fbbf24; margin: 0 auto; animation: bounce 0.5s ease-in-out infinite; }
        .indicator-label { background: #fbbf24; color: #000; padding: 6px 16px; border-radius: 8px; font-weight: 700; font-size: 14px; margin-bottom: 8px; }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 3px; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="dancing-ninja">ü•∑</div>
        <div style="margin-top:20px;font-size:18px;">Loading network...</div>
        <span style="font-size:14px;color:#9ca3af;">This takes about 30 seconds</span>
    </div>

    <!-- Toast container for background ZIP notifications -->
    <div id="zip-toast-container"></div>

    <!-- Multi-Connects Analytics Box -->
    <div id="advanced-analytics">
        <div id="analytics-header">
            <h3>Multi-Connects</h3>
            <div style="display:flex;align-items:center;gap:8px;">
                <button id="back-to-network-btn" style="display:none;" title="Back to full network">‚Üê Back</button>
                <button id="collapse-btn" title="Collapse panel">Collapse</button>
            </div>
        </div>
        <div id="analytics-content">
            <div class="analytics-description">
                Find tight-knit circles where everyone knows everyone. Ranked by strength (docs/pair).
            </div>
            <div class="multiconnect-controls">
                <label>Group Size Range:</label>
                <div style="display:flex;align-items:center;gap:8px;margin:8px 0;">
                    <input type="number" id="min-clique-size" min="3" max="20" value="3" style="width:50px;padding:6px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:4px;color:#fff;text-align:center;">
                    <span style="color:#6b7280;">to</span>
                    <input type="number" id="max-clique-size" min="3" max="50" value="50" style="width:50px;padding:6px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:4px;color:#fff;text-align:center;">
                    <span style="color:#6b7280;font-size:11px;">people</span>
                </div>
            </div>
            <div style="display:flex;gap:8px;">
                <button class="analytics-btn" id="find-multiconnects-btn" style="flex:1;">Find Tight Circles</button>
            </div>
            <div id="multiconnects-results"></div>
        </div>
    </div>

    <div id="controls" style="display:none">
        <h1>EDGI FOIA Network</h1>
        <div class="explain">
            <b>Connections</b> = entities in same documents.<br>
            <b>Click</b> or <b>search</b> to explore.
        </div>
        <div class="entity-toggle">
            <div class="toggle-title">Show Entities</div>
            <div class="entity-toggle-btns">
                <button class="entity-toggle-btn" data-type="all">Both</button>
                <button class="entity-toggle-btn active" data-type="person">People</button>
                <button class="entity-toggle-btn" data-type="org">Orgs</button>
            </div>
        </div>
        <div class="stat">People: <b id="pc">0</b> | Orgs: <b id="oc">0</b></div>
        <div class="stat">Nodes: <b id="nc">0</b> | Edges: <b id="ec">0</b></div>
        <input type="text" id="search" placeholder="Search for person or organization...">
        <div id="results"></div>
        <label>Min Documents: <span id="fv">50</span></label>
        <input type="range" id="filter" min="5" max="500" value="50">
        <div class="legend">
            <div class="legend-title">Document Frequency</div>
            <div class="legend-item"><div class="legend-dot" style="background:#ef4444"></div> 500+</div>
            <div class="legend-item"><div class="legend-dot" style="background:#f59e0b"></div> 100-500</div>
            <div class="legend-item"><div class="legend-dot" style="background:#eab308"></div> 50-100</div>
            <div class="legend-item"><div class="legend-dot" style="background:#22c55e"></div> 20-50</div>
            <div class="legend-item"><div class="legend-dot" style="background:#3b82f6"></div> &lt;20</div>
        </div>
    </div>

    <div id="info">
        <button id="minimize-btn" title="Minimize">‚àí</button>
        <h3 id="iname"></h3>
        <div class="info-content">
            <div class="stat">Documents: <b id="idocs"></b></div>
            <div class="stat">Connected to: <b id="iconn"></b></div>
            <button id="toxicdocs-btn" class="btn">Search ToxicDocs</button>
            <button id="search-between-btn" class="btn">Search network between</button>
            <button id="reorient-btn" class="btn">Re-orient network around</button>
            <button id="download-zip-btn" class="btn">Get ZIP of all PDFs</button>
            <button id="list-connections-btn" class="btn">List All Connections</button>
            <div id="connections-list"></div>
            <button id="clear-btn" class="btn">Clear Selection</button>
        </div>
    </div>

    <button id="print-network-btn">Export Network Data</button>
    <div id="isolate-toggle"><button id="isolate-btn">üîì Unlock</button></div>
    <div id="zoom-controls">
        <button id="zoom-in">+</button>
        <button id="zoom-out">‚àí</button>
        <button id="zoom-reset">‚åÇ</button>
    </div>
    <div id="search-indicator"><div class="indicator-label">Found!</div><div class="indicator-arrow"></div></div>
    <div id="node-ring"></div>
    <div id="sigma-container"></div>

<script>
let allData = null;
let graph = null;
let renderer = null;
let lockedNode = null;
let isolateMode = false;
let isolateCentralNode = null;
let isFromSearch = false;
let entityTypeFilter = "person";
let currentPersonName = "";
let currentEdgeNode = null;  // Track clicked edge node for "search between" feature
let currentEdgeDocIds = [];  // Track doc_ids for current edge (for ZIP download)

function getColor(count, type) {
    if (type === 'org') {
        if (count > 500) return "#c084fc";
        if (count > 100) return "#a855f7";
        if (count > 50) return "#8b5cf6";
        return "#7c3aed";
    }
    if (count > 500) return "#ef4444";
    if (count > 100) return "#f59e0b";
    if (count > 50) return "#eab308";
    if (count > 20) return "#22c55e";
    return "#3b82f6";
}

function getSize(count, type, isCentral) {
    if (isCentral) return 20;
    if (type === 'org') return 8;
    return Math.sqrt(count) * 0.4 + 3;
}

// Load pre-computed layout data
fetch("edgi_network_layout.json")
    .then(r => r.json())
    .then(data => {
        allData = data;
        renderGraph(50);
    })
    .catch(e => document.getElementById("loading").innerHTML = "Error: " + e.message);

function renderGraph(minDocs) {
    if (renderer) { renderer.kill(); renderer = null; }
    document.getElementById("sigma-container").innerHTML = "";

    // Filter nodes - use pre-computed positions
    const nodes = allData.nodes.filter(n => {
        if (n.count < minDocs) return false;
        if (n.x === undefined) return false; // Skip nodes without positions
        const nodeType = n.type || 'person';
        if (entityTypeFilter === 'person' && nodeType !== 'person') return false;
        if (entityTypeFilter === 'org' && nodeType !== 'org') return false;
        return true;
    });

    const nodeIds = new Set(nodes.map(n => n.id));

    // Filter edges
    const edges = allData.edges.filter(e => {
        if (!nodeIds.has(e.source) || !nodeIds.has(e.target)) return false;
        return true;
    });

    // Create graph with pre-computed positions
    graph = new graphology.Graph();

    nodes.forEach(n => {
        const nodeType = n.type || 'person';
        graph.addNode(n.id, {
            x: n.x,
            y: n.y,
            size: getSize(n.count, nodeType, false),
            color: getColor(n.count, nodeType),
            label: n.id,
            count: n.count,
            entityType: nodeType,
            origColor: getColor(n.count, nodeType),
            origSize: getSize(n.count, nodeType, false)
        });
    });

    edges.forEach((e, i) => {
        if (graph.hasNode(e.source) && graph.hasNode(e.target) && !graph.hasEdge(e.source, e.target)) {
            graph.addEdge(e.source, e.target, {
                weight: e.weight,
                size: Math.max(0.3, Math.log(e.weight + 1) * 0.3),
                color: "rgba(255,255,255,0.12)"
            });
        }
    });

    // Stats
    document.getElementById("pc").textContent = nodes.filter(n => (n.type || 'person') === 'person').length;
    document.getElementById("oc").textContent = nodes.filter(n => n.type === 'org').length;
    document.getElementById("nc").textContent = graph.order;
    document.getElementById("ec").textContent = graph.size;

    // Create renderer - NO LAYOUT COMPUTATION!
    renderer = new Sigma(graph, document.getElementById("sigma-container"), {
        renderLabels: true,
        labelRenderedSizeThreshold: 10,
        labelFont: "system-ui, sans-serif",
        labelColor: { color: "#ffffff" },
        labelSize: 11,
        minCameraRatio: 0.02,
        maxCameraRatio: 3,
        enableEdgeHoverEvents: false,
        defaultDrawNodeHover: () => {}
    });

    renderer.on("clickNode", ({ node }) => lockNode(node));
    renderer.on("enterNode", ({ node }) => { if (!lockedNode) highlightNode(node); });
    renderer.on("leaveNode", () => { if (!lockedNode) resetHighlight(); });
    renderer.on("clickStage", () => { if (lockedNode && !isolateMode) clearSelection(); });

    document.getElementById("loading").style.display = "none";
    document.getElementById("controls").style.display = "block";
}

function highlightNode(nodeId) {
    const neighbors = new Set(graph.neighbors(nodeId));
    neighbors.add(nodeId);

    graph.forEachNode((n, a) => {
        graph.setNodeAttribute(n, "color", neighbors.has(n) ? a.origColor : "rgba(60,60,60,0.3)");
        graph.setNodeAttribute(n, "size", neighbors.has(n) ? (n === nodeId ? a.origSize * 1.5 : a.origSize) : a.origSize * 0.5);
    });

    graph.forEachEdge((e, a, s, t) => {
        const connected = s === nodeId || t === nodeId;
        graph.setEdgeAttribute(e, "color", connected ? "#a78bfa" : "rgba(60,60,60,0.05)");
        graph.setEdgeAttribute(e, "size", connected ? a.size * 2 : a.size);
    });

    showInfo(nodeId);
}

function resetHighlight() {
    graph.forEachNode((n, a) => {
        graph.setNodeAttribute(n, "color", a.origColor);
        graph.setNodeAttribute(n, "size", a.origSize);
    });
    graph.forEachEdge((e, a) => {
        graph.setEdgeAttribute(e, "color", "rgba(255,255,255,0.12)");
        graph.setEdgeAttribute(e, "size", Math.max(0.3, Math.log((a.weight || 1) + 1) * 0.3));
    });
    hideInfo();
}

function showInfo(nodeId) {
    const a = graph.getNodeAttributes(nodeId);
    currentPersonName = nodeId;
    currentEdgeNode = null;  // Reset - no edge node selected

    let badges = `<span class="badge ${a.entityType}">${a.entityType === 'org' ? 'Org' : 'Person'}</span>`;

    document.getElementById("iname").innerHTML = nodeId + badges;
    document.getElementById("idocs").textContent = a.count + " docs";
    document.getElementById("iconn").textContent = graph.neighbors(nodeId).length + " entities";
    document.getElementById("connections-list").innerHTML = "";
    document.getElementById("search-between-btn").style.display = "none";  // Hide by default
    document.getElementById("reorient-btn").style.display = "none";  // Hide by default
    document.getElementById("download-zip-btn").style.display = "none";  // Hide by default
    document.getElementById("info").style.display = "block";
}

function hideInfo() {
    document.getElementById("info").style.display = "none";
    document.getElementById("info").classList.remove("locked");
    document.getElementById("clear-btn").style.display = "none";
    document.getElementById("search-between-btn").style.display = "none";
    document.getElementById("reorient-btn").style.display = "none";
    document.getElementById("download-zip-btn").style.display = "none";
    currentEdgeNode = null;
    currentEdgeDocIds = [];
}

function lockNode(nodeId) {
    lockedNode = nodeId;
    isolateMode = true;
    document.getElementById("isolate-btn").classList.add("active");
    document.getElementById("isolate-btn").textContent = "üîí Locked";
    renderIsolated(nodeId);
}

function renderIsolated(selectedId) {
    if (renderer) { renderer.kill(); renderer = null; }
    // Clear any residual canvas elements
    const container = document.getElementById("sigma-container");
    container.innerHTML = "";

    // Get ALL connections from full data (ignore minDocs)
    const connEdges = allData.edges.filter(e => e.source === selectedId || e.target === selectedId);
    const connIds = new Set([selectedId]);
    connEdges.forEach(e => { connIds.add(e.source); connIds.add(e.target); });

    // Filter by entity type only
    const connNodes = allData.nodes.filter(n => {
        if (!connIds.has(n.id)) return false;
        if (n.id === selectedId) return true;
        const t = n.type || 'person';
        if (entityTypeFilter === 'person' && t !== 'person') return false;
        if (entityTypeFilter === 'org' && t !== 'org') return false;
        return true;
    });

    const visIds = new Set(connNodes.map(n => n.id));
    const visEdges = connEdges.filter(e => visIds.has(e.source) && visIds.has(e.target));

    graph = new graphology.Graph();

    // Position: central node at center, others in circle around it
    const cx = 500, cy = 500;
    const otherNodes = connNodes.filter(n => n.id !== selectedId);

    // Add central node first
    const centralNode = connNodes.find(n => n.id === selectedId);
    if (centralNode) {
        const t = centralNode.type || 'person';
        graph.addNode(centralNode.id, {
            x: cx, y: cy,
            size: getSize(centralNode.count, t, true),
            color: "#fbbf24",
            label: centralNode.id,
            count: centralNode.count,
            entityType: t,
            origColor: "#fbbf24",
            origSize: getSize(centralNode.count, t, true)
        });
    }

    // Add other nodes in a circle
    otherNodes.forEach((n, i) => {
        const t = n.type || 'person';
        const angle = (i / Math.max(otherNodes.length, 1)) * 2 * Math.PI;
        const r = 300 + (i % 3) * 50; // Vary radius slightly
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;

        const size = getSize(n.count, t, false);
        const color = getColor(n.count, t);

        graph.addNode(n.id, { x, y, size, color, label: n.id, count: n.count, entityType: t, origColor: color, origSize: size });
    });

    visEdges.forEach(e => {
        if (graph.hasNode(e.source) && graph.hasNode(e.target) && !graph.hasEdge(e.source, e.target)) {
            graph.addEdge(e.source, e.target, { weight: e.weight, size: Math.max(0.5, Math.log(e.weight + 1) * 0.5), color: "#a78bfa" });
        }
    });

    // Stats
    document.getElementById("pc").textContent = connNodes.filter(n => (n.type || 'person') === 'person').length;
    document.getElementById("oc").textContent = connNodes.filter(n => n.type === 'org').length;
    document.getElementById("nc").textContent = graph.order;
    document.getElementById("ec").textContent = graph.size;

    renderer = new Sigma(graph, document.getElementById("sigma-container"), {
        renderLabels: true,
        labelRenderedSizeThreshold: 0,
        labelFont: "system-ui, sans-serif",
        labelColor: { color: "#ffffff" },
        labelSize: 12,
        minCameraRatio: 0.1,
        maxCameraRatio: 3,
        enableEdgeHoverEvents: false,
        defaultDrawNodeHover: () => {}
    });

    renderer.on("clickNode", ({ node }) => {
        if (node !== selectedId) highlightEdgeTo(selectedId, node);
        else resetToCenter(selectedId);  // Click central node to reset
    });
    renderer.on("clickStage", () => resetToCenter(selectedId));

    // Update ring position on camera changes (zoom/pan)
    renderer.getCamera().on("updated", () => {
        if (currentEdgeNode) showNodeRing(currentEdgeNode);
    });

    lockedNode = selectedId;
    isolateCentralNode = selectedId;
    showInfo(selectedId);
    document.getElementById("info").classList.add("locked");
    document.getElementById("clear-btn").style.display = "block";
    document.getElementById("print-network-btn").style.display = "block";
    showAnalyticsPanel();

    if (isFromSearch) {
        setTimeout(() => showSearchIndicator(selectedId), 300);
        isFromSearch = false;
    }

    setTimeout(() => {
        if (renderer) {
            const camera = renderer.getCamera();
            camera.setState({ x: 0.5, y: 0.5, ratio: 0.8 });
        }
    }, 50);
}

function showNodeRing(nodeId) {
    const ring = document.getElementById("node-ring");

    // Get viewport coordinates from Sigma
    const viewportPos = renderer?.graphToViewport(graph.getNodeAttributes(nodeId));
    const displayData = renderer?.getNodeDisplayData(nodeId);

    if (viewportPos) {
        const displayedSize = displayData?.size || 10;
        const ringSize = displayedSize * 2 + 6;  // Just slightly larger than the node
        ring.style.left = viewportPos.x + "px";
        ring.style.top = viewportPos.y + "px";
        ring.style.width = ringSize + "px";
        ring.style.height = ringSize + "px";
        ring.style.display = "block";
    }
}

function hideNodeRing() {
    document.getElementById("node-ring").style.display = "none";
}

function highlightEdgeTo(centralId, clickedId) {
    currentPersonName = clickedId;

    graph.forEachNode(n => {
        const a = graph.getNodeAttributes(n);
        const isClicked = n === clickedId;
        const isCentral = n === centralId;
        graph.setNodeAttribute(n, "color", (isCentral || isClicked) ? "#fbbf24" : a.origColor);
    });

    // Show white ring around clicked edge node
    showNodeRing(clickedId);

    graph.forEachEdge((e, a, s, t) => {
        const isTarget = (s === centralId && t === clickedId) || (s === clickedId && t === centralId);
        const baseSize = Math.max(0.5, Math.log((a.weight || 1) + 1) * 0.5);
        graph.setEdgeAttribute(e, "color", isTarget ? "#fbbf24" : "#a78bfa");
        graph.setEdgeAttribute(e, "size", isTarget ? baseSize * 3 : baseSize);
    });

    showInfo(clickedId);

    // Set AFTER showInfo (which resets it to null)
    currentEdgeNode = clickedId;

    // Show "Search between" button with both names
    const searchBetweenBtn = document.getElementById("search-between-btn");
    searchBetweenBtn.textContent = `Search between ${clickedId} & ${centralId}`;
    searchBetweenBtn.style.display = "block";

    // Show "Re-orient" button
    const reorientBtn = document.getElementById("reorient-btn");
    reorientBtn.textContent = `Re-orient network around ${clickedId}`;
    reorientBtn.style.display = "block";

    // Find edge doc_ids and show ZIP button
    const edge = allData.edges.find(e =>
        (e.source === centralId && e.target === clickedId) ||
        (e.source === clickedId && e.target === centralId)
    );
    currentEdgeDocIds = edge ? (edge.doc_ids || []) : [];
    const zipBtn = document.getElementById("download-zip-btn");
    if (currentEdgeDocIds.length > 0) {
        zipBtn.textContent = `Get ZIP of ${currentEdgeDocIds.length} PDFs`;
        zipBtn.style.display = "block";
    } else {
        zipBtn.style.display = "none";
    }
}


function resetToCenter(centralId) {
    currentEdgeNode = null;  // Reset edge node
    currentEdgeDocIds = [];  // Reset doc_ids
    hideNodeRing();  // Hide the ring
    graph.forEachNode(n => {
        const a = graph.getNodeAttributes(n);
        graph.setNodeAttribute(n, "color", n === centralId ? "#fbbf24" : a.origColor);
    });
    graph.forEachEdge((e, a) => {
        graph.setEdgeAttribute(e, "color", "#a78bfa");
        graph.setEdgeAttribute(e, "size", Math.max(0.5, Math.log((a.weight||1)+1)*0.5));
    });
    lockedNode = centralId;
    showInfo(centralId);
    document.getElementById("search-between-btn").style.display = "none";
    document.getElementById("reorient-btn").style.display = "none";
    document.getElementById("download-zip-btn").style.display = "none";
}

function showSearchIndicator(nodeId) {
    const ind = document.getElementById("search-indicator");
    const pos = renderer?.getNodeDisplayData(nodeId);
    if (pos) {
        ind.style.left = pos.x + "px";
        ind.style.top = (pos.y - 70) + "px";
        ind.style.display = "block";
        setTimeout(() => ind.style.display = "none", 3000);
    }
}

function clearSelection() {
    if (isolateMode) exitLockMode();
    else { lockedNode = null; resetHighlight(); }
}

function exitLockMode() {
    isolateMode = false;
    isolateCentralNode = null;
    lockedNode = null;
    hideNodeRing();
    document.getElementById("isolate-btn").classList.remove("active");
    document.getElementById("isolate-btn").textContent = "üîì Unlock";
    document.getElementById("print-network-btn").style.display = "none";
    hideAnalyticsPanel();
    hideInfo();
    renderGraph(+document.getElementById("filter").value);
}

// Search
document.getElementById("search").addEventListener("input", e => {
    const q = e.target.value.toLowerCase();
    const res = document.getElementById("results");
    res.innerHTML = "";
    if (q.length < 2) return;

    allData.nodes.filter(n => n.id.toLowerCase().includes(q)).sort((a,b) => b.count - a.count).slice(0, 8).forEach(m => {
        const div = document.createElement("div");
        div.className = "result";
        div.textContent = m.id + " (" + m.count + " docs)";
        div.onclick = () => {
            isFromSearch = true;
            isolateMode = true;
            document.getElementById("isolate-btn").classList.add("active");
            document.getElementById("isolate-btn").textContent = "üîí Locked";
            renderIsolated(m.id);
            document.getElementById("search").value = "";
            res.innerHTML = "";
        };
        res.appendChild(div);
    });
});

// Filter slider
const slider = document.getElementById("filter");
slider.oninput = () => document.getElementById("fv").textContent = slider.value;
slider.onchange = () => { exitLockMode(); renderGraph(+slider.value); };

// Entity toggle - filters current view without resetting
document.querySelectorAll('.entity-toggle-btn').forEach(btn => {
    btn.onclick = () => {
        document.querySelectorAll('.entity-toggle-btn').forEach(b => b.classList.remove('active', 'org'));
        btn.classList.add('active');
        if (btn.dataset.type === 'org') btn.classList.add('org');
        entityTypeFilter = btn.dataset.type;

        // If viewing an isolated node, just re-filter that view
        if (isolateCentralNode) {
            hideNodeRing();
            renderIsolated(isolateCentralNode);
        } else {
            // Otherwise, re-render the main graph
            exitLockMode();
            renderGraph(+document.getElementById("filter").value);
        }
    };
});

// Lock button
document.getElementById("isolate-btn").onclick = () => { if (isolateMode) exitLockMode(); };

// Clear button
document.getElementById("clear-btn").onclick = e => {
    e.stopPropagation();
    if (isolateMode && isolateCentralNode) resetToCenter(isolateCentralNode);
    else clearSelection();
};

// Zoom
document.getElementById("zoom-in").onclick = () => renderer?.getCamera().animate({ ratio: renderer.getCamera().ratio / 1.5 }, { duration: 200 });
document.getElementById("zoom-out").onclick = () => renderer?.getCamera().animate({ ratio: renderer.getCamera().ratio * 1.5 }, { duration: 200 });
document.getElementById("zoom-reset").onclick = () => renderer?.getCamera().animate({ x: 0.5, y: 0.5, ratio: 1 }, { duration: 300 });

// Export Network Data - generates a text file with all connections
document.getElementById("print-network-btn").onclick = () => {
    if (!isolateCentralNode) return;

    // Get all connections for the central node
    const centralId = isolateCentralNode;
    const connEdges = allData.edges.filter(e => e.source === centralId || e.target === centralId);

    // Build list of connections with weights
    var connections = [];
    connEdges.forEach(function(e) {
        var otherId = e.source === centralId ? e.target : e.source;
        var otherNode = allData.nodes.find(function(n) { return n.id === otherId; });
        var nodeType = otherNode ? (otherNode.type || 'person') : 'unknown';

        // Apply current entity filter
        if (entityTypeFilter === 'person' && nodeType !== 'person') return;
        if (entityTypeFilter === 'org' && nodeType !== 'org') return;

        connections.push({
            name: otherId,
            type: nodeType,
            cooccurrences: e.weight
        });
    });

    // Sort by co-occurrences descending
    connections.sort(function(a, b) { return b.cooccurrences - a.cooccurrences; });

    // Generate text content
    var lines = [];
    lines.push("NETWORK DATA EXPORT");
    lines.push("===================");
    lines.push("");
    lines.push("Central Entity: " + centralId);
    lines.push("Filter: " + (entityTypeFilter === 'all' ? 'Both People & Orgs' : entityTypeFilter === 'person' ? 'People Only' : 'Orgs Only'));
    lines.push("Total Connections: " + connections.length);
    lines.push("Export Date: " + new Date().toLocaleString());
    lines.push("");
    lines.push("CONNECTIONS (sorted by co-occurrences)");
    lines.push("--------------------------------------");
    lines.push("");

    connections.forEach(function(c, i) {
        var typeLabel = c.type === 'org' ? '[ORG]' : '[PERSON]';
        lines.push((i + 1) + ". " + c.name + " " + typeLabel);
        lines.push("   Co-occurrences: " + c.cooccurrences);
        lines.push("");
    });

    // Create and download file
    var content = lines.join("\n");
    var blob = new Blob([content], { type: "text/plain" });
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = url;
    a.download = centralId.replace(/[^a-zA-Z0-9]/g, "_") + "_network.txt";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};

// ToxicDocs
document.getElementById("toxicdocs-btn").onclick = e => {
    e.stopPropagation();
    window.open("https://www.toxicdocs.org/search?q=" + encodeURIComponent('"' + currentPersonName + '"'), "_blank");
};

// List connections
document.getElementById("list-connections-btn").onclick = e => {
    e.stopPropagation();
    if (!lockedNode) return;

    const conns = allData.edges.filter(e => e.source === lockedNode || e.target === lockedNode)
        .map(e => {
            const oid = e.source === lockedNode ? e.target : e.source;
            const on = allData.nodes.find(n => n.id === oid);
            return { id: oid, type: on?.type || 'person', weight: e.weight, count: on?.count || 0 };
        })
        .filter(c => c.id !== "Sierra Club")  // Too ubiquitous, clutters results
        .sort((a,b) => b.weight - a.weight);

    const list = document.getElementById("connections-list");
    list.innerHTML = `<div style="padding:10px 0;border-top:1px solid rgba(255,255,255,0.1);margin-top:10px;font-size:11px;color:#6b7280;">${conns.length} connections</div>`;

    conns.forEach(c => {
        const div = document.createElement("div");
        div.className = "conn-item";
        div.innerHTML = `
            <span class="conn-icons">
                <span class="conn-icon reorient" title="Re-orient around ${c.id}">‚óé</span>
                <span class="conn-icon search" title="Search on ToxicDocs">‚Üó</span>
            </span>
            ${c.type === 'org' ? 'üè¢' : 'üë§'} <b>${c.id}</b> <span>(${c.weight} shared)</span>
        `;
        // Re-orient icon click
        div.querySelector('.conn-icon.reorient').onclick = ev => {
            ev.stopPropagation();
            hideNodeRing();
            renderIsolated(c.id);
        };
        // Search icon click
        div.querySelector('.conn-icon.search').onclick = ev => {
            ev.stopPropagation();
            window.open("https://www.toxicdocs.org/search?q=" + encodeURIComponent(`"${lockedNode}" "${c.id}"`), "_blank");
        };
        list.appendChild(div);
    });
};

// Search between button - searches ToxicDocs for both the edge node and central node
document.getElementById("search-between-btn").onclick = (e) => {
    e.stopPropagation();
    if (currentEdgeNode && isolateCentralNode) {
        const query = `"${currentEdgeNode}" "${isolateCentralNode}"`;
        window.open("https://www.toxicdocs.org/search?q=" + encodeURIComponent(query), "_blank");
    }
};

// Re-orient button - re-centers the network around the clicked edge node
document.getElementById("reorient-btn").onclick = (e) => {
    e.stopPropagation();
    if (currentEdgeNode) {
        hideNodeRing();
        // If viewing a clique, exit clique view
        if (viewingClique) {
            viewingClique = false;
            document.getElementById("back-to-network-btn").style.display = "none";
            document.querySelectorAll(".clique-result-item").forEach(el => el.classList.remove("active"));
        }
        renderIsolated(currentEdgeNode);
    }
};

// Toast notification system for background ZIP creation
let zipToastCounter = 0;

function createZipToast(name1, name2, docCount) {
    var toastId = "zip-toast-" + (++zipToastCounter);
    var container = document.getElementById("zip-toast-container");

    var toast = document.createElement("div");
    toast.id = toastId;
    toast.className = "zip-toast";
    toast.innerHTML =
        '<div class="zip-toast-header">' +
            '<span class="zip-toast-title">Creating ZIP</span>' +
            '<button class="zip-toast-close" onclick="closeZipToast(\'' + toastId + '\')">&times;</button>' +
        '</div>' +
        '<div class="zip-toast-body">' +
            '<strong>' + name1 + '</strong> &harr; <strong>' + name2 + '</strong><br>' +
            'Downloading ' + docCount + ' PDFs...' +
        '</div>' +
        '<div class="zip-toast-progress"><div class="zip-toast-progress-bar"></div></div>';

    container.appendChild(toast);
    return toastId;
}

function updateZipToast(toastId, success, data) {
    var toast = document.getElementById(toastId);
    if (!toast) return;

    if (success) {
        toast.className = "zip-toast success";
        var body = toast.querySelector(".zip-toast-body");
        body.innerHTML =
            '<strong>ZIP Ready!</strong> ' + data.doc_count + ' PDFs<br>' +
            '<a href="' + data.download_url + '" target="_blank" class="zip-toast-link">Download ZIP</a>';
        // Auto-close after 30 seconds
        setTimeout(function() { closeZipToast(toastId); }, 30000);
    } else {
        toast.className = "zip-toast error";
        var body = toast.querySelector(".zip-toast-body");
        body.innerHTML = '<strong>Error:</strong> ' + (data.error || "Unknown error");
        var progress = toast.querySelector(".zip-toast-progress");
        if (progress) progress.style.display = "none";
        // Auto-close after 10 seconds
        setTimeout(function() { closeZipToast(toastId); }, 10000);
    }
}

function closeZipToast(toastId) {
    var toast = document.getElementById(toastId);
    if (!toast) return;
    toast.classList.add("closing");
    setTimeout(function() { toast.remove(); }, 300);
}

// Download ZIP button - downloads all PDFs for the connection (runs in background)
document.getElementById("download-zip-btn").onclick = (e) => {
    e.stopPropagation();
    if (currentEdgeDocIds.length === 0) return;

    // Capture current values before user navigates away
    var docIds = currentEdgeDocIds.slice();
    var name1 = isolateCentralNode || "Person1";
    var name2 = currentEdgeNode || "Person2";

    // Show toast notification
    var toastId = createZipToast(name1, name2, docIds.length);

    // Brief button feedback then reset
    var btn = document.getElementById("download-zip-btn");
    var originalText = btn.textContent;
    btn.textContent = "Request sent!";
    setTimeout(function() { btn.textContent = originalText; }, 1500);

    // Fetch in background - user can continue exploring
    fetch("https://toxicdocs.tools/zip-service/create-zip", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            doc_ids: docIds,
            name1: name1,
            name2: name2
        })
    })
    .then(function(r) { return r.json(); })
    .then(function(data) {
        if (data.success) {
            updateZipToast(toastId, true, data);
        } else {
            updateZipToast(toastId, false, data);
        }
    })
    .catch(function(err) {
        updateZipToast(toastId, false, { error: err.message });
    });
};

// Minimize button
document.getElementById("minimize-btn").onclick = (e) => {
    e.stopPropagation();
    const info = document.getElementById("info");
    const btn = document.getElementById("minimize-btn");
    info.classList.toggle("minimized");
    btn.textContent = info.classList.contains("minimized") ? "+" : "‚àí";
    btn.title = info.classList.contains("minimized") ? "Expand" : "Minimize";
};

// ============================================
// MULTI-CONNECTS ANALYTICS
// ============================================

var viewingClique = false;  // Track if viewing a clique subnetwork
var savedNetworkState = null;  // Store network state before viewing clique

// Toggle analytics panel collapse
document.getElementById("collapse-btn").onclick = function(e) {
    e.stopPropagation();
    var content = document.getElementById("analytics-content");
    var isCollapsed = content.style.display === "none";
    content.style.display = isCollapsed ? "block" : "none";
    this.textContent = isCollapsed ? "Collapse" : "Expand";
};


// Get current network as adjacency list
function getCurrentNetworkGraph() {
    if (!isolateCentralNode) return null;

    var centralId = isolateCentralNode;
    var connEdges = allData.edges.filter(function(e) {
        return e.source === centralId || e.target === centralId;
    });

    var nodeIds = new Set([centralId]);
    connEdges.forEach(function(e) {
        nodeIds.add(e.source);
        nodeIds.add(e.target);
    });

    var nodes = [];
    allData.nodes.forEach(function(n) {
        if (!nodeIds.has(n.id)) return;
        if (n.id === centralId) { nodes.push(n); return; }
        var t = n.type || 'person';
        if (entityTypeFilter === 'person' && t !== 'person') return;
        if (entityTypeFilter === 'org' && t !== 'org') return;
        nodes.push(n);
    });

    var nodeIdSet = new Set(nodes.map(function(n) { return n.id; }));
    var adj = {};
    nodes.forEach(function(n) { adj[n.id] = new Set(); });

    allData.edges.forEach(function(e) {
        if (nodeIdSet.has(e.source) && nodeIdSet.has(e.target)) {
            adj[e.source].add(e.target);
            adj[e.target].add(e.source);
        }
    });

    return { nodes: nodes, adj: adj, centralId: centralId, nodeIdSet: nodeIdSet };
}

// Find ALL MAXIMAL cliques using Bron-Kerbosch algorithm
// Maximal = cannot be extended by adding more nodes
function findMaximalCliques(adj) {
    var cliques = [];
    var nodes = Object.keys(adj);

    function bronKerbosch(R, P, X) {
        // A clique is maximal when P and X are both empty
        if (P.length === 0 && X.length === 0) {
            if (R.length >= 3) {  // Only care about groups of 3+
                cliques.push(R.slice());
            }
            return;
        }

        // Choose pivot to minimize branching
        var pivot = P.length > 0 ? P[0] : X[0];
        var pivotNeighbors = adj[pivot] || new Set();

        // Process nodes not connected to pivot
        var toProcess = P.filter(function(v) { return !pivotNeighbors.has(v); });

        for (var i = 0; i < toProcess.length; i++) {
            var v = toProcess[i];
            var neighbors = adj[v] || new Set();

            var newR = R.concat([v]);
            var newP = P.filter(function(u) { return neighbors.has(u); });
            var newX = X.filter(function(u) { return neighbors.has(u); });

            bronKerbosch(newR, newP, newX);

            P = P.filter(function(u) { return u !== v; });
            X.push(v);
        }
    }

    bronKerbosch([], nodes, []);
    return cliques;
}

// Build edge weight lookup
function getEdgeWeight(a, b) {
    var edge = allData.edges.find(function(e) {
        return (e.source === a && e.target === b) || (e.source === b && e.target === a);
    });
    return edge ? (edge.weight || 1) : 0;
}

// Calculate total connection strength of a clique
function getCliqueStrength(members) {
    var total = 0;
    for (var i = 0; i < members.length; i++) {
        for (var j = i + 1; j < members.length; j++) {
            total += getEdgeWeight(members[i], members[j]);
        }
    }
    return total;
}

// Find tight circles (maximal cliques containing the central person)
function findMultiConnects() {
    var net = getCurrentNetworkGraph();
    if (!net) return;

    var minSize = parseInt(document.getElementById("min-clique-size").value) || 3;
    var maxSize = parseInt(document.getElementById("max-clique-size").value) || 50;
    var centralId = net.centralId;

    var resultsDiv = document.getElementById("multiconnects-results");
    resultsDiv.innerHTML = '<div style="color:#a78bfa;padding:12px;text-align:center;">Finding tight circles...</div>';

    // Use setTimeout to allow UI to update
    setTimeout(function() {
        var allCliques = findMaximalCliques(net.adj);

        // Calculate data for each clique
        var cliquesWithData = allCliques.filter(function(c) {
            return c.indexOf(centralId) !== -1;
        }).map(function(c) {
            var totalStrength = getCliqueStrength(c);
            var numPairs = (c.length * (c.length - 1)) / 2;
            var avgStrength = numPairs > 0 ? Math.round(totalStrength / numPairs) : 0;
            return {
                members: c,
                size: c.length,
                strength: totalStrength,
                avgStrength: avgStrength  // Average docs per pair - the "tightness"
            };
        });

        // Filter by size range only
        var cliques = cliquesWithData.filter(function(c) {
            return c.size >= minSize && c.size <= maxSize;
        });

        if (cliques.length === 0) {
            resultsDiv.innerHTML = '<div style="color:#ef4444;padding:12px;text-align:center;">No tight circles found in that size range.<br><span style="font-size:11px;color:#6b7280;margin-top:6px;display:block;">Try adjusting the size range.</span></div>';
            return;
        }

        // Sort by average strength (tightness) first, then by size
        cliques.sort(function(a, b) {
            if (b.avgStrength !== a.avgStrength) return b.avgStrength - a.avgStrength;  // Tightest first
            return b.size - a.size;  // Then larger groups
        });

        var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin:12px 0;">';
        html += '<span style="color:#10b981;font-weight:600;">' + centralId + ' is in ' + cliques.length + ' tight circle' + (cliques.length !== 1 ? 's' : '') + '</span>';
        html += '<div style="display:flex;gap:6px;">';
        html += '<button onclick="event.stopPropagation();downloadCirclesData();" style="padding:4px 10px;background:rgba(59,130,246,0.2);border:1px solid rgba(59,130,246,0.3);border-radius:4px;color:#60a5fa;font-size:11px;cursor:pointer;">Full Data</button>';
        html += '<button onclick="event.stopPropagation();clearMultiConnectsResults();" style="padding:4px 10px;background:rgba(239,68,68,0.2);border:1px solid rgba(239,68,68,0.3);border-radius:4px;color:#f87171;font-size:11px;cursor:pointer;">Clear</button>';
        html += '</div></div>';
        html += '<div id="results-list">';

        // Store full clique data for export
        window.foundCliquesData = cliques;

        cliques.slice(0, 30).forEach(function(item, i) {
            var members = item.members;
            // Color-code tightness: green for very tight, yellow for medium, gray for weak
            var tightColor = item.avgStrength >= 50 ? '#10b981' : (item.avgStrength >= 10 ? '#fbbf24' : '#9ca3af');
            html += '<div class="clique-result-item" data-clique-index="' + i + '">';
            html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">';
            html += '<span style="font-size:12px;color:#fff;font-weight:600;cursor:pointer;" onclick="viewClique(' + i + ')">' + item.size + '-person circle</span>';
            html += '<div style="display:flex;align-items:center;gap:8px;">';
            html += '<span style="font-size:10px;color:' + tightColor + ';font-weight:600;">' + item.avgStrength + ' docs/pair</span>';
            html += '<button onclick="event.stopPropagation();downloadCircleZip(' + i + ');" style="padding:2px 8px;background:rgba(16,185,129,0.2);border:1px solid rgba(16,185,129,0.3);border-radius:4px;color:#34d399;font-size:10px;cursor:pointer;">Get ZIP</button>';
            html += '</div></div>';
            html += '<div class="clique-members" onclick="viewClique(' + i + ')" style="cursor:pointer;">';
            members.forEach(function(member) {
                var isCentral = member === centralId;
                html += '<span class="clique-member" style="' + (isCentral ? 'background:#fbbf24;color:#000;' : '') + '">' + member + '</span>';
            });
            html += '</div></div>';
        });

        if (cliques.length > 30) {
            html += '<div style="color:#6b7280;font-size:11px;text-align:center;margin-top:10px;">Showing tightest 30 of ' + cliques.length + ' circles</div>';
        }
        html += '</div>'; // close results-list

        resultsDiv.innerHTML = html;

        // Store cliques for viewing
        window.foundCliques = cliques.map(function(c) { return c.members; });

    }, 50);
}

// Clear results and reset
function clearMultiConnectsResults() {
    document.getElementById("multiconnects-results").innerHTML = "";
    window.foundCliques = [];
    window.foundCliquesData = [];

    // If viewing a clique, go back to network
    if (viewingClique) {
        backToNetwork();
    }
}

// Get all doc_ids for edges between clique members
function getCliqueDocIds(members) {
    var docIds = [];
    var seen = {};
    for (var i = 0; i < members.length; i++) {
        for (var j = i + 1; j < members.length; j++) {
            var edge = allData.edges.find(function(e) {
                return (e.source === members[i] && e.target === members[j]) ||
                       (e.source === members[j] && e.target === members[i]);
            });
            if (edge && edge.doc_ids) {
                edge.doc_ids.forEach(function(docId) {
                    if (!seen[docId]) {
                        seen[docId] = true;
                        docIds.push(docId);
                    }
                });
            }
        }
    }
    return docIds;
}

// Download ZIP of all documents for a tight circle
function downloadCircleZip(index) {
    var clique = window.foundCliquesData[index];
    if (!clique) return;

    var members = clique.members;
    var docIds = getCliqueDocIds(members);

    if (docIds.length === 0) {
        alert("No documents found for this circle.");
        return;
    }

    var circleName = clique.size + "-person_circle";
    var toastId = createZipToast(circleName, isolateCentralNode || "circle", docIds.length);

    // Call ZIP service
    fetch("https://toxicdocs.tools/zip-service/create-zip", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            doc_ids: docIds,
            name1: circleName,
            name2: isolateCentralNode || "circle"
        })
    })
    .then(function(r) { return r.json(); })
    .then(function(data) {
        if (data.success) {
            updateZipToast(toastId, true, data);
        } else {
            updateZipToast(toastId, false, data);
        }
    })
    .catch(function(err) {
        updateZipToast(toastId, false, { error: err.message });
    });
}

// Download full data as text file
function downloadCirclesData() {
    var cliques = window.foundCliquesData || [];
    if (cliques.length === 0) {
        alert("No circle data to export.");
        return;
    }

    var centralPerson = isolateCentralNode || "Unknown";
    var lines = [];
    lines.push("TIGHT CIRCLES REPORT");
    lines.push("====================");
    lines.push("Central Person: " + centralPerson);
    lines.push("Total Circles: " + cliques.length);
    lines.push("Generated: " + new Date().toISOString());
    lines.push("");

    cliques.forEach(function(clique, i) {
        lines.push("----------------------------------------");
        lines.push("CIRCLE #" + (i + 1));
        lines.push("Size: " + clique.size + " people");
        lines.push("Strength: " + clique.avgStrength + " docs/pair average");
        lines.push("Total shared docs: " + clique.strength);
        lines.push("Members:");
        clique.members.forEach(function(member) {
            var marker = member === centralPerson ? " (central)" : "";
            lines.push("  - " + member + marker);
        });

        // List doc_ids
        var docIds = getCliqueDocIds(clique.members);
        lines.push("Document IDs (" + docIds.length + "):");
        docIds.forEach(function(docId) {
            lines.push("  " + docId);
        });
        lines.push("");
    });

    // Create and download file
    var content = lines.join("\n");
    var blob = new Blob([content], { type: "text/plain" });
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = url;
    a.download = centralPerson.replace(/[^a-zA-Z0-9]/g, "_") + "_tight_circles.txt";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Toggle results list visibility
function toggleResultsList() {
    var list = document.getElementById("results-list");
    if (!list) return;
    var isHidden = list.style.display === "none";
    list.style.display = isHidden ? "block" : "none";
    // Update the toggle button text
    var btn = list.parentElement.querySelector('button[title="Collapse/Expand"]');
    if (btn) btn.textContent = isHidden ? "‚ñ≤" : "‚ñº";
}

// View a specific clique as a subnetwork
function viewClique(index) {
    var clique = window.foundCliques[index];
    if (!clique) return;

    // Save current state if not already viewing a clique
    if (!viewingClique) {
        savedNetworkState = {
            centralNode: isolateCentralNode
        };
    }

    viewingClique = true;
    document.getElementById("back-to-network-btn").style.display = "block";

    // Highlight selected clique in list
    document.querySelectorAll(".clique-result-item").forEach(function(el) {
        el.classList.remove("active");
    });
    document.querySelector('[data-clique-index="' + index + '"]').classList.add("active");

    // Render just this clique
    renderCliqueNetwork(clique);
}

// Render a clique as a subnetwork
function renderCliqueNetwork(members) {
    if (renderer) { renderer.kill(); renderer = null; }
    document.getElementById("sigma-container").innerHTML = "";

    graph = new graphology.Graph();

    // Position nodes in a circle
    var cx = 500, cy = 500, radius = 200;
    members.forEach(function(id, i) {
        var angle = (i / members.length) * 2 * Math.PI - Math.PI/2;
        var x = cx + Math.cos(angle) * radius;
        var y = cy + Math.sin(angle) * radius;

        var nodeData = allData.nodes.find(function(n) { return n.id === id; });
        var isCentral = id === savedNetworkState.centralNode;
        var color = isCentral ? "#fbbf24" : "#a78bfa";

        graph.addNode(id, {
            x: x, y: y,
            size: isCentral ? 20 : 14,
            color: color,
            label: id,
            origColor: color,
            origSize: isCentral ? 20 : 14
        });
    });

    // Add all edges between clique members
    for (var i = 0; i < members.length; i++) {
        for (var j = i + 1; j < members.length; j++) {
            var edge = allData.edges.find(function(e) {
                return (e.source === members[i] && e.target === members[j]) ||
                       (e.source === members[j] && e.target === members[i]);
            });
            var weight = edge ? edge.weight : 1;
            graph.addEdge(members[i], members[j], {
                size: 2,
                color: "#fbbf24",
                weight: weight
            });
        }
    }

    renderer = new Sigma(graph, document.getElementById("sigma-container"), {
        renderLabels: true,
        labelRenderedSizeThreshold: 0,
        labelFont: "system-ui, sans-serif",
        labelColor: { color: "#ffffff" },
        labelSize: 14,
        minCameraRatio: 0.5,
        maxCameraRatio: 2
    });

    // Allow clicking nodes in clique view to explore them
    renderer.on("clickNode", function(e) {
        var nodeId = e.node;
        var centralNode = savedNetworkState.centralNode;

        // Highlight clicked node
        graph.forEachNode(function(n) {
            var isCentral = n === centralNode;
            var isClicked = n === nodeId;
            graph.setNodeAttribute(n, "color", (isCentral || isClicked) ? "#fbbf24" : "#a78bfa");
        });

        // Show info for this node
        showInfo(nodeId);

        // If not the central node, show reorient button
        if (nodeId !== centralNode) {
            currentEdgeNode = nodeId;
            var reorientBtn = document.getElementById("reorient-btn");
            reorientBtn.textContent = "Re-orient network around " + nodeId;
            reorientBtn.style.display = "block";
        } else {
            // Clicked central node - hide reorient
            currentEdgeNode = null;
            document.getElementById("reorient-btn").style.display = "none";
        }
    });

    // Update stats
    document.getElementById("nc").textContent = members.length;
    document.getElementById("ec").textContent = (members.length * (members.length - 1)) / 2;
}

// Go back to full network from clique view
function backToNetwork() {
    if (!savedNetworkState) return;

    viewingClique = false;
    document.getElementById("back-to-network-btn").style.display = "none";

    // Remove active state from clique items
    document.querySelectorAll(".clique-result-item").forEach(function(el) {
        el.classList.remove("active");
    });

    // Restore the original network
    renderIsolated(savedNetworkState.centralNode);
}

// Wire up multi-connects button
document.getElementById("find-multiconnects-btn").onclick = function() {
    this.textContent = "Finding...";
    var btn = this;
    setTimeout(function() {
        findMultiConnects();
        btn.textContent = "Find Tight Circles";
    }, 50);
};

// Wire up back button
document.getElementById("back-to-network-btn").onclick = function(e) {
    e.stopPropagation();
    backToNetwork();
};

// Show/hide analytics panel with isolated mode
function showAnalyticsPanel() {
    document.getElementById("advanced-analytics").classList.add("visible");
    document.getElementById("multiconnects-results").innerHTML = "";
    viewingClique = false;
    document.getElementById("back-to-network-btn").style.display = "none";
    window.foundCliques = [];
}

function hideAnalyticsPanel() {
    document.getElementById("advanced-analytics").classList.remove("visible");
}

// Highlight connection when clicking a name in analytics results
function highlightAnalyticsNode(nodeId) {
    if (!isolateCentralNode || nodeId === isolateCentralNode) return;

    // Use the existing highlightEdgeTo function
    highlightEdgeTo(isolateCentralNode, nodeId);
}

// Drag functionality for analytics panel - works from anywhere except scrollable content
(function() {
    var panel = document.getElementById("advanced-analytics");
    var content = document.getElementById("analytics-content");
    var isDragging = false;
    var startX, startY, startLeft, startTop;

    panel.addEventListener("mousedown", function(e) {
        // Don't drag if clicking inside scrollable content area (allow scrolling)
        if (content.contains(e.target)) return;
        // Don't drag if clicking buttons
        if (e.target.tagName === "BUTTON" || e.target.tagName === "SPAN") return;

        isDragging = true;
        panel.classList.add("dragging");
        startX = e.clientX;
        startY = e.clientY;

        // Get current position
        var rect = panel.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;

        // Switch to position by top/left instead of bottom/right
        panel.style.bottom = "auto";
        panel.style.right = "auto";
        panel.style.left = startLeft + "px";
        panel.style.top = startTop + "px";

        e.preventDefault();
    });

    document.addEventListener("mousemove", function(e) {
        if (!isDragging) return;

        var dx = e.clientX - startX;
        var dy = e.clientY - startY;

        var newLeft = startLeft + dx;
        var newTop = startTop + dy;

        // Keep panel within viewport
        var maxLeft = window.innerWidth - panel.offsetWidth - 10;
        var maxTop = window.innerHeight - panel.offsetHeight - 10;
        newLeft = Math.max(10, Math.min(newLeft, maxLeft));
        newTop = Math.max(10, Math.min(newTop, maxTop));

        panel.style.left = newLeft + "px";
        panel.style.top = newTop + "px";
    });

    document.addEventListener("mouseup", function() {
        isDragging = false;
        panel.classList.remove("dragging");
    });
})();
</script>
</body>
</html>
