<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>EDGI FOIA Network</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; background: #0a0a0f; font-family: system-ui, -apple-system, sans-serif; overflow: hidden; }
        #sigma-container { width: 100vw; height: 100vh; overflow: hidden; }
        /* Hide any scrollbars or artifacts */
        html, body { overflow: hidden; }
        canvas { display: block; }
        /* Hide Sigma's hover label layer */
        .sigma-hovers { display: none !important; }
        .sigma-container canvas:nth-child(3) { display: none !important; }

        #controls {
            position: fixed; top: 15px; left: 15px;
            background: rgba(15,15,20,0.95); padding: 14px;
            border-radius: 14px; color: #fff; width: 280px; z-index: 10;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }
        h1 { margin: 0 0 8px; font-size: 17px; color: #a78bfa; font-weight: 600; }
        .explain { font-size: 11px; color: #9ca3af; margin-bottom: 10px; line-height: 1.4; }
        .explain b { color: #e5e7eb; }
        .stat { font-size: 11px; color: #9ca3af; margin: 3px 0; }
        .stat b { color: #fff; }

        input[type=text] {
            width: 100%; padding: 10px 12px; margin: 8px 0;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px; color: #fff; font-size: 13px; transition: all 0.2s;
        }
        input[type=text]:focus { outline: none; border-color: #a78bfa; background: rgba(167,139,250,0.1); }
        input[type=text]::placeholder { color: #6b7280; }

        #results { max-height: 120px; overflow-y: auto; }
        .result { padding: 8px 10px; cursor: pointer; font-size: 12px; color: #d1d5db; border-radius: 6px; margin: 2px 0; transition: all 0.15s; }
        .result:hover { background: rgba(167,139,250,0.2); color: #fff; }

        label { display: block; margin-top: 10px; font-size: 10px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; }
        input[type=range] { width: 100%; margin: 6px 0; -webkit-appearance: none; background: rgba(255,255,255,0.1); height: 5px; border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: #a78bfa; border-radius: 50%; cursor: pointer; }

        #info {
            position: fixed; top: 20px; right: 20px;
            background: rgba(15,15,20,0.95); padding: 20px;
            border-radius: 16px; color: #fff; display: none; z-index: 10;
            width: 340px; border: 1px solid rgba(255,255,255,0.1);
            max-height: calc(100vh - 40px); overflow-y: auto;
        }
        #info h3 { margin: 0 0 12px; color: #a78bfa; font-size: 18px; font-weight: 600; padding-right: 30px; }
        #info.locked { border-color: #a78bfa; box-shadow: 0 0 30px rgba(167,139,250,0.2); }
        #info.minimized { height: auto; max-height: none; }
        #info.minimized .info-content { display: none; }
        #minimize-btn {
            position: absolute; top: 16px; right: 16px;
            background: rgba(255,255,255,0.1); border: none; border-radius: 6px;
            color: #9ca3af; width: 28px; height: 28px; cursor: pointer;
            font-size: 16px; line-height: 1; transition: all 0.2s;
        }
        #minimize-btn:hover { background: rgba(255,255,255,0.2); color: #fff; }

        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #a78bfa; font-size: 18px; text-align: center; }
        .dancing-ninja { font-size: 80px; animation: dance 1s ease-in-out infinite; }
        @keyframes dance {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            25% { transform: translateY(-20px) rotate(5deg); }
            50% { transform: translateY(0) rotate(-5deg); }
            75% { transform: translateY(-10px) rotate(5deg); }
        }

        .legend { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        .legend-title { font-size: 10px; color: #6b7280; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
        .legend-item { display: flex; align-items: center; margin: 3px 0; font-size: 10px; color: #9ca3af; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; }

        .btn { display: block; margin-top: 8px; padding: 10px 14px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; width: 100%; font-size: 12px; transition: all 0.2s; text-align: center; }
        #clear-btn { display: none; background: #a78bfa; color: #000; }
        #clear-btn:hover { background: #c4b5fd; }
        #toxicdocs-btn { background: linear-gradient(135deg, #f59e0b, #d97706); color: #000; }
        #toxicdocs-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(245,158,11,0.3); }
        #list-connections-btn { background: rgba(16,185,129,0.2); color: #10b981; border: 1px solid #10b981; }
        #list-connections-btn:hover { background: rgba(16,185,129,0.3); }

        #connections-list { margin-top: 10px; max-height: 200px; overflow-y: auto; }
        .conn-item { padding: 8px 0; font-size: 12px; color: #d1d5db; border-bottom: 1px solid rgba(255,255,255,0.05); transition: color 0.15s; display: flex; align-items: center; }
        .conn-item span { color: #6b7280; }
        .conn-icons { display: flex; gap: 6px; margin-right: 8px; }
        .conn-icon { cursor: pointer; font-size: 14px; padding: 2px 4px; border-radius: 4px; transition: all 0.15s; }
        .conn-icon:hover { background: rgba(255,255,255,0.1); }
        .conn-icon.reorient { color: #10b981; }
        .conn-icon.reorient:hover { color: #34d399; background: rgba(16,185,129,0.2); }
        .conn-icon.search { color: #f59e0b; }
        .conn-icon.search:hover { color: #fbbf24; background: rgba(245,158,11,0.2); }

        #zoom-controls { position: fixed; bottom: 20px; left: 20px; background: rgba(15,15,20,0.95); padding: 12px; border-radius: 12px; z-index: 10; border: 1px solid rgba(255,255,255,0.1); }
        #zoom-controls button { width: 44px; height: 44px; margin: 0 4px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; color: #fff; font-size: 22px; cursor: pointer; transition: all 0.2s; }
        #zoom-controls button:hover { background: #a78bfa; color: #000; }

        #isolate-toggle { position: fixed; bottom: 100px; left: 20px; z-index: 10; }
        #isolate-btn { padding: 14px 28px; background: rgba(255,255,255,0.05); color: #9ca3af; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s; min-width: 130px; }
        #isolate-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        #isolate-btn.active { background: #a78bfa; color: #000; border-color: #a78bfa; }

        #print-network-btn { position: fixed; bottom: 150px; left: 20px; z-index: 10; display: none; padding: 12px 20px; background: rgba(255,255,255,0.05); color: #9ca3af; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; cursor: pointer; font-weight: 500; font-size: 13px; transition: all 0.2s; }
        #print-network-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }


        .entity-toggle { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        .toggle-title { font-size: 10px; color: #6b7280; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
        .entity-toggle-btns { display: flex; gap: 6px; }
        .entity-toggle-btn { flex: 1; padding: 8px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #9ca3af; font-size: 11px; cursor: pointer; text-align: center; transition: all 0.2s; font-weight: 500; }
        .entity-toggle-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .entity-toggle-btn.active { background: #a78bfa; color: #000; border-color: #a78bfa; }
        .entity-toggle-btn.active.org { background: #8b5cf6; }

        .badge { display: inline-block; padding: 3px 8px; border-radius: 6px; font-size: 10px; margin-left: 8px; font-weight: 600; }
        .badge.person { background: rgba(96,165,250,0.2); color: #60a5fa; }
        .badge.org { background: rgba(167,139,250,0.2); color: #a78bfa; }

        #search-indicator { position: fixed; pointer-events: none; z-index: 100; display: none; text-align: center; overflow: hidden; }
        #node-ring { position: fixed; pointer-events: none; z-index: 1000; display: none; border: 3px solid #ffffff; border-radius: 50%; transform: translate(-50%, -50%); }

        /* Search between button - only shows when clicking edge node in isolated mode */
        #search-between-btn {
            display: none;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9); color: #fff;
        }
        #search-between-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(139,92,246,0.3); }
        #reorient-btn {
            display: none;
            background: linear-gradient(135deg, #10b981, #059669); color: #fff;
        }
        #reorient-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(16,185,129,0.3); }
        #download-zip-btn {
            display: none;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: #fff;
        }
        #download-zip-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(59,130,246,0.3); }
        #download-zip-btn.loading { opacity: 0.7; cursor: wait; }

        /* Toast notifications for background ZIP creation */
        #zip-toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .zip-toast {
            background: #1e293b;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 20px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        .zip-toast.closing { animation: slideOut 0.3s ease-in forwards; }
        .zip-toast-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .zip-toast-title { font-weight: 600; color: #fff; font-size: 14px; }
        .zip-toast-close { background: none; border: none; color: #64748b; cursor: pointer; font-size: 18px; padding: 0; line-height: 1; }
        .zip-toast-close:hover { color: #fff; }
        .zip-toast-body { color: #94a3b8; font-size: 13px; }
        .zip-toast-progress { height: 3px; background: rgba(255,255,255,0.1); border-radius: 2px; margin-top: 12px; overflow: hidden; }
        .zip-toast-progress-bar { height: 100%; background: linear-gradient(90deg, #3b82f6, #8b5cf6); border-radius: 2px; animation: progress 2s ease-in-out infinite; width: 30%; }
        @keyframes progress { 0% { transform: translateX(-100%); } 100% { transform: translateX(400%); } }
        .zip-toast.success { border-color: rgba(16,185,129,0.3); }
        .zip-toast.success .zip-toast-progress-bar { background: #10b981; width: 100%; animation: none; }
        .zip-toast.error { border-color: rgba(239,68,68,0.3); }
        .zip-toast-link { display: inline-block; margin-top: 10px; background: linear-gradient(135deg, #10b981, #059669); color: #fff; padding: 8px 16px; border-radius: 6px; text-decoration: none; font-size: 13px; font-weight: 500; }
        .zip-toast-link:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(16,185,129,0.3); }

        .indicator-arrow { width: 0; height: 0; border-left: 15px solid transparent; border-right: 15px solid transparent; border-top: 25px solid #fbbf24; margin: 0 auto; animation: bounce 0.5s ease-in-out infinite; }
        .indicator-label { background: #fbbf24; color: #000; padding: 6px 16px; border-radius: 8px; font-weight: 700; font-size: 14px; margin-bottom: 8px; }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 3px; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="dancing-ninja">ü•∑</div>
        <div style="margin-top:20px;font-size:18px;">Loading network...</div>
        <span style="font-size:14px;color:#9ca3af;">This takes about 30 seconds</span>
    </div>

    <!-- Toast container for background ZIP notifications -->
    <div id="zip-toast-container"></div>


    <div id="controls" style="display:none">
        <h1>EDGI FOIA Network</h1>
        <div class="explain">
            <b>Connections</b> = entities in same documents.<br>
            <b>Click</b> or <b>search</b> to explore.
        </div>
        <div class="entity-toggle">
            <div class="toggle-title">Show Entities</div>
            <div class="entity-toggle-btns">
                <button class="entity-toggle-btn" data-type="all">Both</button>
                <button class="entity-toggle-btn active" data-type="person">People</button>
                <button class="entity-toggle-btn" data-type="org">Orgs</button>
            </div>
        </div>
        <div class="stat">People: <b id="pc">0</b> | Orgs: <b id="oc">0</b></div>
        <div class="stat">Nodes: <b id="nc">0</b> | Edges: <b id="ec">0</b></div>
        <input type="text" id="search" placeholder="Search for person or organization...">
        <div id="results"></div>
        <label>Min Documents: <span id="fv">50</span></label>
        <input type="range" id="filter" min="5" max="500" value="50">
        <div class="legend">
            <div class="legend-title">Document Frequency</div>
            <div class="legend-item"><div class="legend-dot" style="background:#ef4444"></div> 500+</div>
            <div class="legend-item"><div class="legend-dot" style="background:#f59e0b"></div> 100-500</div>
            <div class="legend-item"><div class="legend-dot" style="background:#eab308"></div> 50-100</div>
            <div class="legend-item"><div class="legend-dot" style="background:#22c55e"></div> 20-50</div>
            <div class="legend-item"><div class="legend-dot" style="background:#3b82f6"></div> &lt;20</div>
        </div>
    </div>

    <div id="info">
        <button id="minimize-btn" title="Minimize">‚àí</button>
        <h3 id="iname"></h3>
        <div class="info-content">
            <div class="stat">Documents: <b id="idocs"></b></div>
            <div class="stat">Connected to: <b id="iconn"></b></div>
            <button id="toxicdocs-btn" class="btn">Search ToxicDocs</button>
            <button id="search-between-btn" class="btn">Search network between</button>
            <button id="reorient-btn" class="btn">Re-orient network around</button>
            <button id="download-zip-btn" class="btn">Get ZIP of all PDFs</button>
            <button id="list-connections-btn" class="btn">List All Connections</button>
            <div id="connections-list"></div>
            <button id="clear-btn" class="btn">Clear Selection</button>
        </div>
    </div>

    <button id="print-network-btn">Export Network Data</button>
    <div id="isolate-toggle"><button id="isolate-btn">üîì Unlock</button></div>
    <div id="zoom-controls">
        <button id="zoom-in">+</button>
        <button id="zoom-out">‚àí</button>
        <button id="zoom-reset">‚åÇ</button>
    </div>
    <div id="search-indicator"><div class="indicator-label">Found!</div><div class="indicator-arrow"></div></div>
    <div id="node-ring"></div>
    <div id="sigma-container"></div>

<script>
let allData = null;
let graph = null;
let renderer = null;
let lockedNode = null;
let isolateMode = false;
let isolateCentralNode = null;
let isFromSearch = false;
let entityTypeFilter = "person";
let currentPersonName = "";
let currentEdgeNode = null;  // Track clicked edge node for "search between" feature
let currentEdgeDocIds = [];  // Track doc_ids for current edge (for ZIP download)

function getColor(count, type) {
    if (type === 'org') {
        if (count > 500) return "#c084fc";
        if (count > 100) return "#a855f7";
        if (count > 50) return "#8b5cf6";
        return "#7c3aed";
    }
    if (count > 500) return "#ef4444";
    if (count > 100) return "#f59e0b";
    if (count > 50) return "#eab308";
    if (count > 20) return "#22c55e";
    return "#3b82f6";
}

function getSize(count, type, isCentral) {
    if (isCentral) return 20;
    if (type === 'org') return 8;
    return Math.sqrt(count) * 0.4 + 3;
}

// Load pre-computed layout data
fetch("edgi_network_layout.json")
    .then(r => r.json())
    .then(data => {
        allData = data;
        renderGraph(50);
    })
    .catch(e => document.getElementById("loading").innerHTML = "Error: " + e.message);

function renderGraph(minDocs) {
    if (renderer) { renderer.kill(); renderer = null; }
    document.getElementById("sigma-container").innerHTML = "";

    // Filter nodes - use pre-computed positions
    const nodes = allData.nodes.filter(n => {
        if (n.count < minDocs) return false;
        if (n.x === undefined) return false; // Skip nodes without positions
        const nodeType = n.type || 'person';
        if (entityTypeFilter === 'person' && nodeType !== 'person') return false;
        if (entityTypeFilter === 'org' && nodeType !== 'org') return false;
        return true;
    });

    const nodeIds = new Set(nodes.map(n => n.id));

    // Filter edges
    const edges = allData.edges.filter(e => {
        if (!nodeIds.has(e.source) || !nodeIds.has(e.target)) return false;
        return true;
    });

    // Create graph with pre-computed positions
    graph = new graphology.Graph();

    nodes.forEach(n => {
        const nodeType = n.type || 'person';
        graph.addNode(n.id, {
            x: n.x,
            y: n.y,
            size: getSize(n.count, nodeType, false),
            color: getColor(n.count, nodeType),
            label: n.id,
            count: n.count,
            entityType: nodeType,
            origColor: getColor(n.count, nodeType),
            origSize: getSize(n.count, nodeType, false)
        });
    });

    edges.forEach((e, i) => {
        if (graph.hasNode(e.source) && graph.hasNode(e.target) && !graph.hasEdge(e.source, e.target)) {
            graph.addEdge(e.source, e.target, {
                weight: e.weight,
                size: Math.max(0.3, Math.log(e.weight + 1) * 0.3),
                color: "rgba(255,255,255,0.12)"
            });
        }
    });

    // Stats
    document.getElementById("pc").textContent = nodes.filter(n => (n.type || 'person') === 'person').length;
    document.getElementById("oc").textContent = nodes.filter(n => n.type === 'org').length;
    document.getElementById("nc").textContent = graph.order;
    document.getElementById("ec").textContent = graph.size;

    // Create renderer - NO LAYOUT COMPUTATION!
    renderer = new Sigma(graph, document.getElementById("sigma-container"), {
        renderLabels: true,
        labelRenderedSizeThreshold: 10,
        labelFont: "system-ui, sans-serif",
        labelColor: { color: "#ffffff" },
        labelSize: 11,
        minCameraRatio: 0.02,
        maxCameraRatio: 3,
        enableEdgeHoverEvents: false,
        defaultDrawNodeHover: () => {}
    });

    renderer.on("clickNode", ({ node }) => lockNode(node));
    renderer.on("enterNode", ({ node }) => { if (!lockedNode) highlightNode(node); });
    renderer.on("leaveNode", () => { if (!lockedNode) resetHighlight(); });
    renderer.on("clickStage", () => { if (lockedNode && !isolateMode) clearSelection(); });

    document.getElementById("loading").style.display = "none";
    document.getElementById("controls").style.display = "block";
}

function highlightNode(nodeId) {
    const neighbors = new Set(graph.neighbors(nodeId));
    neighbors.add(nodeId);

    graph.forEachNode((n, a) => {
        graph.setNodeAttribute(n, "color", neighbors.has(n) ? a.origColor : "rgba(60,60,60,0.3)");
        graph.setNodeAttribute(n, "size", neighbors.has(n) ? (n === nodeId ? a.origSize * 1.5 : a.origSize) : a.origSize * 0.5);
    });

    graph.forEachEdge((e, a, s, t) => {
        const connected = s === nodeId || t === nodeId;
        graph.setEdgeAttribute(e, "color", connected ? "#a78bfa" : "rgba(60,60,60,0.05)");
        graph.setEdgeAttribute(e, "size", connected ? a.size * 2 : a.size);
    });

    showInfo(nodeId);
}

function resetHighlight() {
    graph.forEachNode((n, a) => {
        graph.setNodeAttribute(n, "color", a.origColor);
        graph.setNodeAttribute(n, "size", a.origSize);
    });
    graph.forEachEdge((e, a) => {
        graph.setEdgeAttribute(e, "color", "rgba(255,255,255,0.12)");
        graph.setEdgeAttribute(e, "size", Math.max(0.3, Math.log((a.weight || 1) + 1) * 0.3));
    });
    hideInfo();
}

function showInfo(nodeId) {
    const a = graph.getNodeAttributes(nodeId);
    currentPersonName = nodeId;
    currentEdgeNode = null;  // Reset - no edge node selected

    let badges = `<span class="badge ${a.entityType}">${a.entityType === 'org' ? 'Org' : 'Person'}</span>`;

    document.getElementById("iname").innerHTML = nodeId + badges;
    document.getElementById("idocs").textContent = a.count + " docs";
    document.getElementById("iconn").textContent = graph.neighbors(nodeId).length + " entities";
    document.getElementById("connections-list").innerHTML = "";
    document.getElementById("search-between-btn").style.display = "none";  // Hide by default
    document.getElementById("reorient-btn").style.display = "none";  // Hide by default
    document.getElementById("download-zip-btn").style.display = "none";  // Hide by default
    document.getElementById("info").style.display = "block";
}

function hideInfo() {
    document.getElementById("info").style.display = "none";
    document.getElementById("info").classList.remove("locked");
    document.getElementById("clear-btn").style.display = "none";
    document.getElementById("search-between-btn").style.display = "none";
    document.getElementById("reorient-btn").style.display = "none";
    document.getElementById("download-zip-btn").style.display = "none";
    currentEdgeNode = null;
    currentEdgeDocIds = [];
}

function lockNode(nodeId) {
    lockedNode = nodeId;
    isolateMode = true;
    document.getElementById("isolate-btn").classList.add("active");
    document.getElementById("isolate-btn").textContent = "üîí Locked";
    renderIsolated(nodeId);
}

function renderIsolated(selectedId) {
    if (renderer) { renderer.kill(); renderer = null; }
    // Clear any residual canvas elements
    const container = document.getElementById("sigma-container");
    container.innerHTML = "";

    // Get ALL connections from full data (ignore minDocs)
    const connEdges = allData.edges.filter(e => e.source === selectedId || e.target === selectedId);
    const connIds = new Set([selectedId]);
    connEdges.forEach(e => { connIds.add(e.source); connIds.add(e.target); });

    // Filter by entity type only
    const connNodes = allData.nodes.filter(n => {
        if (!connIds.has(n.id)) return false;
        if (n.id === selectedId) return true;
        const t = n.type || 'person';
        if (entityTypeFilter === 'person' && t !== 'person') return false;
        if (entityTypeFilter === 'org' && t !== 'org') return false;
        return true;
    });

    const visIds = new Set(connNodes.map(n => n.id));
    const visEdges = connEdges.filter(e => visIds.has(e.source) && visIds.has(e.target));

    graph = new graphology.Graph();

    // Position: central node at center, others in circle around it
    const cx = 500, cy = 500;
    const otherNodes = connNodes.filter(n => n.id !== selectedId);

    // Add central node first
    const centralNode = connNodes.find(n => n.id === selectedId);
    if (centralNode) {
        const t = centralNode.type || 'person';
        graph.addNode(centralNode.id, {
            x: cx, y: cy,
            size: getSize(centralNode.count, t, true),
            color: "#fbbf24",
            label: centralNode.id,
            count: centralNode.count,
            entityType: t,
            origColor: "#fbbf24",
            origSize: getSize(centralNode.count, t, true)
        });
    }

    // Add other nodes in a circle
    otherNodes.forEach((n, i) => {
        const t = n.type || 'person';
        const angle = (i / Math.max(otherNodes.length, 1)) * 2 * Math.PI;
        const r = 300 + (i % 3) * 50; // Vary radius slightly
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;

        const size = getSize(n.count, t, false);
        const color = getColor(n.count, t);

        graph.addNode(n.id, { x, y, size, color, label: n.id, count: n.count, entityType: t, origColor: color, origSize: size });
    });

    visEdges.forEach(e => {
        if (graph.hasNode(e.source) && graph.hasNode(e.target) && !graph.hasEdge(e.source, e.target)) {
            graph.addEdge(e.source, e.target, { weight: e.weight, size: Math.max(0.5, Math.log(e.weight + 1) * 0.5), color: "#a78bfa" });
        }
    });

    // Stats
    document.getElementById("pc").textContent = connNodes.filter(n => (n.type || 'person') === 'person').length;
    document.getElementById("oc").textContent = connNodes.filter(n => n.type === 'org').length;
    document.getElementById("nc").textContent = graph.order;
    document.getElementById("ec").textContent = graph.size;

    renderer = new Sigma(graph, document.getElementById("sigma-container"), {
        renderLabels: true,
        labelRenderedSizeThreshold: 0,
        labelFont: "system-ui, sans-serif",
        labelColor: { color: "#ffffff" },
        labelSize: 12,
        minCameraRatio: 0.1,
        maxCameraRatio: 3,
        enableEdgeHoverEvents: false,
        defaultDrawNodeHover: () => {}
    });

    renderer.on("clickNode", ({ node }) => {
        if (node !== selectedId) highlightEdgeTo(selectedId, node);
        else resetToCenter(selectedId);  // Click central node to reset
    });
    renderer.on("clickStage", () => resetToCenter(selectedId));

    // Update ring position on camera changes (zoom/pan)
    renderer.getCamera().on("updated", () => {
        if (currentEdgeNode) showNodeRing(currentEdgeNode);
    });

    lockedNode = selectedId;
    isolateCentralNode = selectedId;
    showInfo(selectedId);
    document.getElementById("info").classList.add("locked");
    document.getElementById("clear-btn").style.display = "block";
    document.getElementById("print-network-btn").style.display = "block";
    showAnalyticsPanel();

    if (isFromSearch) {
        setTimeout(() => showSearchIndicator(selectedId), 300);
        isFromSearch = false;
    }

    setTimeout(() => {
        if (renderer) {
            const camera = renderer.getCamera();
            camera.setState({ x: 0.5, y: 0.5, ratio: 0.8 });
        }
    }, 50);
}

function showNodeRing(nodeId) {
    const ring = document.getElementById("node-ring");

    // Get viewport coordinates from Sigma
    const viewportPos = renderer?.graphToViewport(graph.getNodeAttributes(nodeId));
    const displayData = renderer?.getNodeDisplayData(nodeId);

    if (viewportPos) {
        const displayedSize = displayData?.size || 10;
        const ringSize = displayedSize * 2 + 6;  // Just slightly larger than the node
        ring.style.left = viewportPos.x + "px";
        ring.style.top = viewportPos.y + "px";
        ring.style.width = ringSize + "px";
        ring.style.height = ringSize + "px";
        ring.style.display = "block";
    }
}

function hideNodeRing() {
    document.getElementById("node-ring").style.display = "none";
}

function highlightEdgeTo(centralId, clickedId) {
    currentPersonName = clickedId;

    graph.forEachNode(n => {
        const a = graph.getNodeAttributes(n);
        const isClicked = n === clickedId;
        const isCentral = n === centralId;
        graph.setNodeAttribute(n, "color", (isCentral || isClicked) ? "#fbbf24" : a.origColor);
    });

    // Show white ring around clicked edge node
    showNodeRing(clickedId);

    graph.forEachEdge((e, a, s, t) => {
        const isTarget = (s === centralId && t === clickedId) || (s === clickedId && t === centralId);
        const baseSize = Math.max(0.5, Math.log((a.weight || 1) + 1) * 0.5);
        graph.setEdgeAttribute(e, "color", isTarget ? "#fbbf24" : "#a78bfa");
        graph.setEdgeAttribute(e, "size", isTarget ? baseSize * 3 : baseSize);
    });

    showInfo(clickedId);

    // Set AFTER showInfo (which resets it to null)
    currentEdgeNode = clickedId;

    // Show "Search between" button with both names
    const searchBetweenBtn = document.getElementById("search-between-btn");
    searchBetweenBtn.textContent = `Search between ${clickedId} & ${centralId}`;
    searchBetweenBtn.style.display = "block";

    // Show "Re-orient" button
    const reorientBtn = document.getElementById("reorient-btn");
    reorientBtn.textContent = `Re-orient network around ${clickedId}`;
    reorientBtn.style.display = "block";

    // Find edge doc_ids and show ZIP button
    const edge = allData.edges.find(e =>
        (e.source === centralId && e.target === clickedId) ||
        (e.source === clickedId && e.target === centralId)
    );
    currentEdgeDocIds = edge ? (edge.doc_ids || []) : [];
    const zipBtn = document.getElementById("download-zip-btn");
    if (currentEdgeDocIds.length > 0) {
        zipBtn.textContent = `Get ZIP of ${currentEdgeDocIds.length} PDFs`;
        zipBtn.style.display = "block";
    } else {
        zipBtn.style.display = "none";
    }
}


function resetToCenter(centralId) {
    currentEdgeNode = null;  // Reset edge node
    currentEdgeDocIds = [];  // Reset doc_ids
    hideNodeRing();  // Hide the ring
    graph.forEachNode(n => {
        const a = graph.getNodeAttributes(n);
        graph.setNodeAttribute(n, "color", n === centralId ? "#fbbf24" : a.origColor);
    });
    graph.forEachEdge((e, a) => {
        graph.setEdgeAttribute(e, "color", "#a78bfa");
        graph.setEdgeAttribute(e, "size", Math.max(0.5, Math.log((a.weight||1)+1)*0.5));
    });
    lockedNode = centralId;
    showInfo(centralId);
    document.getElementById("search-between-btn").style.display = "none";
    document.getElementById("reorient-btn").style.display = "none";
    document.getElementById("download-zip-btn").style.display = "none";
}

function showSearchIndicator(nodeId) {
    const ind = document.getElementById("search-indicator");
    const pos = renderer?.getNodeDisplayData(nodeId);
    if (pos) {
        ind.style.left = pos.x + "px";
        ind.style.top = (pos.y - 70) + "px";
        ind.style.display = "block";
        setTimeout(() => ind.style.display = "none", 3000);
    }
}

function clearSelection() {
    if (isolateMode) exitLockMode();
    else { lockedNode = null; resetHighlight(); }
}

function exitLockMode() {
    isolateMode = false;
    isolateCentralNode = null;
    lockedNode = null;
    hideNodeRing();
    document.getElementById("isolate-btn").classList.remove("active");
    document.getElementById("isolate-btn").textContent = "üîì Unlock";
    document.getElementById("print-network-btn").style.display = "none";
    hideAnalyticsPanel();
    hideInfo();
    renderGraph(+document.getElementById("filter").value);
}

// Search
document.getElementById("search").addEventListener("input", e => {
    const q = e.target.value.toLowerCase();
    const res = document.getElementById("results");
    res.innerHTML = "";
    if (q.length < 2) return;

    allData.nodes.filter(n => n.id.toLowerCase().includes(q)).sort((a,b) => b.count - a.count).slice(0, 8).forEach(m => {
        const div = document.createElement("div");
        div.className = "result";
        div.textContent = m.id + " (" + m.count + " docs)";
        div.onclick = () => {
            isFromSearch = true;
            isolateMode = true;
            document.getElementById("isolate-btn").classList.add("active");
            document.getElementById("isolate-btn").textContent = "üîí Locked";
            renderIsolated(m.id);
            document.getElementById("search").value = "";
            res.innerHTML = "";
        };
        res.appendChild(div);
    });
});

// Filter slider
const slider = document.getElementById("filter");
slider.oninput = () => document.getElementById("fv").textContent = slider.value;
slider.onchange = () => { exitLockMode(); renderGraph(+slider.value); };

// Entity toggle - filters current view without resetting
document.querySelectorAll('.entity-toggle-btn').forEach(btn => {
    btn.onclick = () => {
        document.querySelectorAll('.entity-toggle-btn').forEach(b => b.classList.remove('active', 'org'));
        btn.classList.add('active');
        if (btn.dataset.type === 'org') btn.classList.add('org');
        entityTypeFilter = btn.dataset.type;

        // If viewing an isolated node, just re-filter that view
        if (isolateCentralNode) {
            hideNodeRing();
            renderIsolated(isolateCentralNode);
        } else {
            // Otherwise, re-render the main graph
            exitLockMode();
            renderGraph(+document.getElementById("filter").value);
        }
    };
});

// Lock button
document.getElementById("isolate-btn").onclick = () => { if (isolateMode) exitLockMode(); };

// Clear button
document.getElementById("clear-btn").onclick = e => {
    e.stopPropagation();
    if (isolateMode && isolateCentralNode) resetToCenter(isolateCentralNode);
    else clearSelection();
};

// Zoom
document.getElementById("zoom-in").onclick = () => renderer?.getCamera().animate({ ratio: renderer.getCamera().ratio / 1.5 }, { duration: 200 });
document.getElementById("zoom-out").onclick = () => renderer?.getCamera().animate({ ratio: renderer.getCamera().ratio * 1.5 }, { duration: 200 });
document.getElementById("zoom-reset").onclick = () => renderer?.getCamera().animate({ x: 0.5, y: 0.5, ratio: 1 }, { duration: 300 });

// Export Network Data - generates a text file with all connections
document.getElementById("print-network-btn").onclick = () => {
    if (!isolateCentralNode) return;

    // Get all connections for the central node
    const centralId = isolateCentralNode;
    const connEdges = allData.edges.filter(e => e.source === centralId || e.target === centralId);

    // Build list of connections with weights
    var connections = [];
    connEdges.forEach(function(e) {
        var otherId = e.source === centralId ? e.target : e.source;
        var otherNode = allData.nodes.find(function(n) { return n.id === otherId; });
        var nodeType = otherNode ? (otherNode.type || 'person') : 'unknown';

        // Apply current entity filter
        if (entityTypeFilter === 'person' && nodeType !== 'person') return;
        if (entityTypeFilter === 'org' && nodeType !== 'org') return;

        connections.push({
            name: otherId,
            type: nodeType,
            cooccurrences: e.weight
        });
    });

    // Sort by co-occurrences descending
    connections.sort(function(a, b) { return b.cooccurrences - a.cooccurrences; });

    // Generate text content
    var lines = [];
    lines.push("NETWORK DATA EXPORT");
    lines.push("===================");
    lines.push("");
    lines.push("Central Entity: " + centralId);
    lines.push("Filter: " + (entityTypeFilter === 'all' ? 'Both People & Orgs' : entityTypeFilter === 'person' ? 'People Only' : 'Orgs Only'));
    lines.push("Total Connections: " + connections.length);
    lines.push("Export Date: " + new Date().toLocaleString());
    lines.push("");
    lines.push("CONNECTIONS (sorted by co-occurrences)");
    lines.push("--------------------------------------");
    lines.push("");

    connections.forEach(function(c, i) {
        var typeLabel = c.type === 'org' ? '[ORG]' : '[PERSON]';
        lines.push((i + 1) + ". " + c.name + " " + typeLabel);
        lines.push("   Co-occurrences: " + c.cooccurrences);
        lines.push("");
    });

    // Create and download file
    var content = lines.join("\n");
    var blob = new Blob([content], { type: "text/plain" });
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = url;
    a.download = centralId.replace(/[^a-zA-Z0-9]/g, "_") + "_network.txt";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};

// ToxicDocs
document.getElementById("toxicdocs-btn").onclick = e => {
    e.stopPropagation();
    window.open("https://www.toxicdocs.org/search?q=" + encodeURIComponent('"' + currentPersonName + '"'), "_blank");
};

// List connections
document.getElementById("list-connections-btn").onclick = e => {
    e.stopPropagation();
    if (!lockedNode) return;

    const conns = allData.edges.filter(e => e.source === lockedNode || e.target === lockedNode)
        .map(e => {
            const oid = e.source === lockedNode ? e.target : e.source;
            const on = allData.nodes.find(n => n.id === oid);
            return { id: oid, type: on?.type || 'person', weight: e.weight, count: on?.count || 0 };
        })
        .filter(c => c.id !== "Sierra Club")  // Too ubiquitous, clutters results
        .sort((a,b) => b.weight - a.weight);

    const list = document.getElementById("connections-list");
    list.innerHTML = `<div style="padding:10px 0;border-top:1px solid rgba(255,255,255,0.1);margin-top:10px;font-size:11px;color:#6b7280;">${conns.length} connections</div>`;

    conns.forEach(c => {
        const div = document.createElement("div");
        div.className = "conn-item";
        div.innerHTML = `
            <span class="conn-icons">
                <span class="conn-icon reorient" title="Re-orient around ${c.id}">‚óé</span>
                <span class="conn-icon search" title="Search on ToxicDocs">‚Üó</span>
            </span>
            ${c.type === 'org' ? 'üè¢' : 'üë§'} <b>${c.id}</b> <span>(${c.weight} shared)</span>
        `;
        // Re-orient icon click
        div.querySelector('.conn-icon.reorient').onclick = ev => {
            ev.stopPropagation();
            hideNodeRing();
            renderIsolated(c.id);
        };
        // Search icon click
        div.querySelector('.conn-icon.search').onclick = ev => {
            ev.stopPropagation();
            window.open("https://www.toxicdocs.org/search?q=" + encodeURIComponent(`"${lockedNode}" "${c.id}"`), "_blank");
        };
        list.appendChild(div);
    });
};

// Search between button - searches ToxicDocs for both the edge node and central node
document.getElementById("search-between-btn").onclick = (e) => {
    e.stopPropagation();
    if (currentEdgeNode && isolateCentralNode) {
        const query = `"${currentEdgeNode}" "${isolateCentralNode}"`;
        window.open("https://www.toxicdocs.org/search?q=" + encodeURIComponent(query), "_blank");
    }
};

// Re-orient button - re-centers the network around the clicked edge node
document.getElementById("reorient-btn").onclick = (e) => {
    e.stopPropagation();
    if (currentEdgeNode) {
        hideNodeRing();
        renderIsolated(currentEdgeNode);
    }
};

// Toast notification system for background ZIP creation
let zipToastCounter = 0;

function createZipToast(name1, name2, docCount) {
    var toastId = "zip-toast-" + (++zipToastCounter);
    var container = document.getElementById("zip-toast-container");

    var toast = document.createElement("div");
    toast.id = toastId;
    toast.className = "zip-toast";
    toast.innerHTML =
        '<div class="zip-toast-header">' +
            '<span class="zip-toast-title">Creating ZIP</span>' +
            '<button class="zip-toast-close" onclick="closeZipToast(\'' + toastId + '\')">&times;</button>' +
        '</div>' +
        '<div class="zip-toast-body">' +
            '<strong>' + name1 + '</strong> &harr; <strong>' + name2 + '</strong><br>' +
            'Downloading ' + docCount + ' PDFs...' +
        '</div>' +
        '<div class="zip-toast-progress"><div class="zip-toast-progress-bar"></div></div>';

    container.appendChild(toast);
    return toastId;
}

function updateZipToast(toastId, success, data) {
    var toast = document.getElementById(toastId);
    if (!toast) return;

    if (success) {
        toast.className = "zip-toast success";
        var body = toast.querySelector(".zip-toast-body");
        body.innerHTML =
            '<strong>ZIP Ready!</strong> ' + data.doc_count + ' PDFs<br>' +
            '<a href="' + data.download_url + '" target="_blank" class="zip-toast-link">Download ZIP</a>';
        // Auto-close after 30 seconds
        setTimeout(function() { closeZipToast(toastId); }, 30000);
    } else {
        toast.className = "zip-toast error";
        var body = toast.querySelector(".zip-toast-body");
        body.innerHTML = '<strong>Error:</strong> ' + (data.error || "Unknown error");
        var progress = toast.querySelector(".zip-toast-progress");
        if (progress) progress.style.display = "none";
        // Auto-close after 10 seconds
        setTimeout(function() { closeZipToast(toastId); }, 10000);
    }
}

function closeZipToast(toastId) {
    var toast = document.getElementById(toastId);
    if (!toast) return;
    toast.classList.add("closing");
    setTimeout(function() { toast.remove(); }, 300);
}

// Download ZIP button - downloads all PDFs for the connection (runs in background)
document.getElementById("download-zip-btn").onclick = (e) => {
    e.stopPropagation();
    if (currentEdgeDocIds.length === 0) return;

    // Capture current values before user navigates away
    var docIds = currentEdgeDocIds.slice();
    var name1 = isolateCentralNode || "Person1";
    var name2 = currentEdgeNode || "Person2";

    // Show toast notification
    var toastId = createZipToast(name1, name2, docIds.length);

    // Brief button feedback then reset
    var btn = document.getElementById("download-zip-btn");
    var originalText = btn.textContent;
    btn.textContent = "Request sent!";
    setTimeout(function() { btn.textContent = originalText; }, 1500);

    // Fetch in background - user can continue exploring
    fetch("https://toxicdocs.tools/zip-service/create-zip", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            doc_ids: docIds,
            name1: name1,
            name2: name2
        })
    })
    .then(function(r) { return r.json(); })
    .then(function(data) {
        if (data.success) {
            updateZipToast(toastId, true, data);
        } else {
            updateZipToast(toastId, false, data);
        }
    })
    .catch(function(err) {
        updateZipToast(toastId, false, { error: err.message });
    });
};

// Minimize button
document.getElementById("minimize-btn").onclick = (e) => {
    e.stopPropagation();
    const info = document.getElementById("info");
    const btn = document.getElementById("minimize-btn");
    info.classList.toggle("minimized");
    btn.textContent = info.classList.contains("minimized") ? "+" : "‚àí";
    btn.title = info.classList.contains("minimized") ? "Expand" : "Minimize";
};

// Stub functions for removed analytics panel
function showAnalyticsPanel() {}
function hideAnalyticsPanel() {}
</script>
</body>
</html>
